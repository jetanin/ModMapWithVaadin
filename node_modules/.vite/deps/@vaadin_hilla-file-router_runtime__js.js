import {
  Navigate,
  createBrowserRouter,
  useLocation,
  useMatches
} from "./chunk-L5RWN7JJ.js";
import "./chunk-PNVLN6DD.js";
import {
  d
} from "./chunk-PTVTUJK6.js";
import {
  require_jsx_runtime
} from "./chunk-SKCOSPGW.js";
import "./chunk-BQPM45KC.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-AVWG52NB.js";
import {
  require_react
} from "./chunk-IF5A3MEL.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-file-router/runtime/createRoute.js
function extendModule(module, config) {
  return {
    ...module,
    config: {
      ...config,
      ...module == null ? void 0 : module.config
    }
  };
}
function createRoute(path, moduleOrChildren, children) {
  let module;
  if (Array.isArray(moduleOrChildren)) {
    children = moduleOrChildren;
  } else {
    module = moduleOrChildren;
  }
  return {
    path,
    module,
    children
  };
}

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-auth/useAuth.js
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var initialState = {
  initializing: true,
  loading: false
};
var AuthContext = (0, import_react.createContext)({
  state: initialState,
  login() {
    throw new Error("AuthContext not initialized");
  },
  logout() {
    throw new Error("AuthContext not initialized");
  },
  hasAccess() {
    throw new Error("AuthContext not initialized");
  }
});

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function ProtectedRoute({ redirectPath, access, element }) {
  const { state: { initializing, loading }, hasAccess } = (0, import_react2.useContext)(AuthContext);
  const location = useLocation();
  if (initializing || loading) {
    return (0, import_jsx_runtime2.jsx)(
      "div",
      // This is for copilot to recognize this
      {}
    );
  }
  if (!hasAccess(access)) {
    return (0, import_jsx_runtime2.jsx)(Navigate, {
      to: redirectPath,
      state: { from: location },
      replace: true
    });
  }
  return element;
}
ProtectedRoute.type = "ProtectedRoute";
function protectRoute(route, redirectPath = "/login") {
  var _a2;
  const { handle } = route;
  const requiresAuth = (handle == null ? void 0 : handle.loginRequired) ?? (handle == null ? void 0 : handle.requiresLogin) ?? ((_a2 = handle == null ? void 0 : handle.rolesAllowed) == null ? void 0 : _a2.length);
  if (requiresAuth) {
    route.element = (0, import_jsx_runtime2.jsx)(ProtectedRoute, {
      redirectPath,
      access: handle,
      element: route.element
    });
  }
  return route;
}

// node_modules/@vaadin/hilla-react-auth/index.js
((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `@vaadin/hilla-react-auth/${feature}` : "@vaadin/hilla-react-auth",
    version: "24.7.2"
  });
})();

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-file-router/shared/convertComponentNameToTitle.js
var viewPattern = /view/giu;
var upperCaseSplitPattern = /(?=[A-Z])/gu;
function convertComponentNameToTitle(component) {
  let name;
  if (component && (typeof component === "object" || typeof component === "function") && "name" in component && typeof component.name === "string") {
    ({ name } = component);
  } else {
    name = String(component);
  }
  return name.replace(viewPattern, "").split(upperCaseSplitPattern).join(" ");
}

// node_modules/@vaadin/hilla-file-router/shared/transformTree.js
function transformTree(nodes, context, transformer) {
  return transformer(nodes, (n, ctx = context) => transformTree(n, ctx, transformer), context);
}

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
function isReactRouteModule(module) {
  return "default" in module && typeof module.default === "function" || "config" in module && typeof module.config === "object";
}
function createRouteKey(route) {
  return `${route.path ?? ""}-${route.children ? "n" : "i"}`;
}
var RouteHandleFlags = function(RouteHandleFlags2) {
  RouteHandleFlags2["FLOW_LAYOUT"] = "flowLayout";
  RouteHandleFlags2["IGNORE_FALLBACK"] = "ignoreFallback";
  RouteHandleFlags2["SKIP_LAYOUTS"] = "skipLayouts";
  return RouteHandleFlags2;
}(RouteHandleFlags || {});
function getRouteHandleFlag(route, flag) {
  if (typeof route.handle === "object" && flag in route.handle) {
    return route.handle[flag];
  }
  return void 0;
}
var _modifiers, _RouterConfigurationBuilder_instances, withLayoutSkipping_fn;
var RouterConfigurationBuilder = class {
  constructor() {
    __privateAdd(this, _RouterConfigurationBuilder_instances);
    __privateAdd(this, _modifiers, []);
  }
  /**
  * Adds the given routes to the current list of routes. All the routes are
  * deeply merged to preserve the path uniqueness.
  *
  * @param routes - A list of routes to add to the current list.
  */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
  * Adds the given file routes to the current list of routes. All the routes
  * are transformed to React RouterObjects and deeply merged to preserve the
  * path uniqueness.
  *
  * @param routes - A list of routes to add to the current list.
  */
  withFileRoutes(routes) {
    return this.update(routes, ({ original, overriding: added, children }) => {
      var _a2, _b, _c;
      if (added) {
        const { module, path, flowLayout } = added;
        if (module && !isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default or a ViewConfig object exported as "config"`);
        }
        const element = (module == null ? void 0 : module.default) ? (0, import_react3.createElement)(module.default) : void 0;
        const handle = {
          ...module == null ? void 0 : module.config,
          title: ((_a2 = module == null ? void 0 : module.config) == null ? void 0 : _a2.title) ?? convertComponentNameToTitle(module == null ? void 0 : module.default),
          flowLayout: ((_b = module == null ? void 0 : module.config) == null ? void 0 : _b.flowLayout) ?? flowLayout
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: ((_c = module == null ? void 0 : module.config) == null ? void 0 : _c.route) ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
  * Adds the given server route element to each branch of the current list of
  * routes.
  *
  * @param component - The React component to add to each branch of the
  * current list of routes.
  * @param config - An optional configuration that will be applied to
  * each fallback component.
  */
  withFallback(component, config) {
    this.withLayout(component);
    const fallbackRoutes = [{
      path: "*",
      element: (0, import_react3.createElement)(component),
      handle: config
    }, {
      index: true,
      element: (0, import_react3.createElement)(component),
      handle: config
    }];
    this.update(fallbackRoutes, ({ original, overriding: added, children, dupe }) => {
      if (original && !getRouteHandleFlag(original, RouteHandleFlags.IGNORE_FALLBACK) && !dupe) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? (path == null ? void 0 : path.includes("?")))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
  * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.
  *
  * @param layoutComponent - layout component to use, usually Flow
  */
  withLayout(layoutComponent) {
    __privateGet(this, _modifiers).push((originalRoutes) => {
      if (!originalRoutes) {
        return originalRoutes;
      }
      const result = transformTree(originalRoutes, null, (routes, next) => routes.reduce((lists, route) => {
        const { server, client, ambivalent } = next(route.children ?? []);
        const flag = getRouteHandleFlag(route, RouteHandleFlags.FLOW_LAYOUT);
        if (flag === true) {
          lists.server.push({
            ...route,
            children: route.children ? [...server, ...ambivalent] : void 0
          });
        } else if (server.length > 0) {
          lists.server.push({
            ...route,
            children: route.children ? server : void 0
          });
        }
        if (flag === false || client.length > 0) {
          lists.client.push({
            ...route,
            children: route.children ? client : void 0
          });
        }
        if (flag === void 0 && (lists.server.every(({ path }) => path !== route.path) || ambivalent.length > 0)) {
          lists.ambivalent.push({
            ...route,
            children: route.children ? ambivalent : void 0
          });
        }
        return lists;
      }, {
        server: [],
        client: [],
        ambivalent: []
      }));
      return [
        ...result.server.length ? [{
          element: (0, import_react3.createElement)(layoutComponent),
          children: result.server,
          handle: { [RouteHandleFlags.IGNORE_FALLBACK]: true }
        }] : [],
        ...result.client,
        ...result.ambivalent
      ];
    });
    return this;
  }
  /**
  * Protects all the routes that require authentication. For more details see
  * {@link @vaadin/hilla-react-auth#protectRoutes} function.
  *
  * @param redirectPath - the path to redirect to if the route is protected
  * and the user is not authenticated.
  */
  protect(redirectPath) {
    this.update(void 0, ({ original: route, children }) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = ({ original, overriding, children }) => ({
    ...original,
    ...overriding,
    children
  })) {
    __privateGet(this, _modifiers).push((existingRoutes) => transformTree([existingRoutes, routes], null, ([original, added], next) => {
      if (original && added) {
        const final = [];
        const pathKeys = /* @__PURE__ */ new Set([...original.map(createRouteKey), ...added.map(createRouteKey)]);
        for (const pathKey of pathKeys) {
          const originalRoutes = original.filter((r) => createRouteKey(r) === pathKey);
          const addedRoutes = added.filter((r) => createRouteKey(r) === pathKey);
          if (addedRoutes.length > 1) {
            throw new Error("Adding multiple routes with the same path is not allowed");
          }
          const addedRoute = addedRoutes[0];
          if (originalRoutes.length > 0 && addedRoute) {
            for (let i = 0; i < originalRoutes.length; i++) {
              final.push(callback({
                original: originalRoutes[i],
                overriding: addedRoute,
                children: next([originalRoutes[i].children, addedRoute.children]),
                dupe: i < originalRoutes.length - 1
              }) ?? originalRoutes[i]);
            }
          } else if (originalRoutes.length > 0) {
            for (let i = 0; i < originalRoutes.length; i++) {
              final.push(callback({
                original: originalRoutes[i],
                children: next([originalRoutes[i].children, void 0]),
                dupe: i < originalRoutes.length - 1
              }) ?? originalRoutes[i]);
            }
          } else {
            const result = callback({
              overriding: addedRoute,
              children: next([void 0, addedRoute.children]),
              dupe: false
            });
            if (result) {
              final.push(result);
            }
          }
        }
        return final.filter((r) => r != null);
      } else if (original) {
        return original.map((route) => callback({
          original: route,
          children: next([route.children, void 0]),
          dupe: false
        })).filter((r) => r != null);
      } else if (added) {
        return added.map((route) => callback({
          overriding: route,
          children: next([void 0, route.children]),
          dupe: false
        })).filter((r) => r != null);
      }
      return void 0;
    }));
    return this;
  }
  /**
  * Builds the router with the current list of routes.
  */
  build(options) {
    __privateMethod(this, _RouterConfigurationBuilder_instances, withLayoutSkipping_fn).call(this);
    const routes = __privateGet(this, _modifiers).reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], {
        basename: new URL(document.baseURI).pathname,
        ...options
      })
    };
  }
};
_modifiers = new WeakMap();
_RouterConfigurationBuilder_instances = new WeakSet();
withLayoutSkipping_fn = function() {
  __privateGet(this, _modifiers).push((originalRoutes) => {
    if (!originalRoutes) {
      return originalRoutes;
    }
    const result = transformTree(originalRoutes, null, (routes, next) => routes.reduce((lists, route) => {
      var _a2;
      if (getRouteHandleFlag(route, RouteHandleFlags.SKIP_LAYOUTS)) {
        lists.skipped.push(route);
        return lists;
      }
      if (!((_a2 = route.children) == null ? void 0 : _a2.length)) {
        lists.regular.push(route);
        return lists;
      }
      const { skipped, regular } = next(route.children ?? []);
      if (skipped.length > 0) {
        const { element, ...rest } = route;
        lists.skipped.push({
          ...rest,
          children: skipped
        });
      }
      if (regular.length > 0) {
        lists.regular.push({
          ...route,
          children: regular
        });
      }
      return lists;
    }, {
      skipped: [],
      regular: []
    }));
    return [...result.skipped.length ? [{
      children: result.skipped,
      handle: { [RouteHandleFlags.IGNORE_FALLBACK]: true }
    }] : [], ...result.regular];
  });
  return this;
};

// node_modules/@vaadin/hilla-file-router/runtime/useViewConfig.js
function useViewConfig() {
  var _a2;
  const matches = useMatches();
  return (_a2 = matches[matches.length - 1]) == null ? void 0 : _a2.handle;
}

// node_modules/@vaadin/hilla-file-router/runtime/createMenuItems.js
var _a;
var viewsSignal = d((_a = window.Vaadin) == null ? void 0 : _a.views);
function isExcluded(value) {
  var _a2;
  return !!((_a2 = value.menu) == null ? void 0 : _a2.exclude);
}
function hasVariablePathSegment(path) {
  return path.split("/").some((segment) => segment.startsWith(":"));
}
function createMenuItems() {
  ((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
    vaadinObj.registrations ?? (vaadinObj.registrations = []);
    vaadinObj.registrations.push({
      is: feature ? `@vaadin/hilla-file-router/${feature}` : "@vaadin/hilla-file-router",
      version: "24.7.2"
    });
  })("createMenuItems", window.Vaadin);
  const collator = new Intl.Collator("en-US");
  if (!viewsSignal.value) {
    return [];
  }
  const views = Object.entries(viewsSignal.value);
  return views.filter(([path, value]) => !isExcluded(value) && !hasVariablePathSegment(path)).map(([path, config]) => {
    var _a2, _b, _c;
    return {
      to: path,
      icon: (_a2 = config.menu) == null ? void 0 : _a2.icon,
      title: ((_b = config.menu) == null ? void 0 : _b.title) ?? config.title,
      order: (_c = config.menu) == null ? void 0 : _c.order
    };
  }).sort((menuA, menuB) => {
    const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);
    return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);
  });
}
if (import.meta.hot) {
  import.meta.hot.on("fs-route-update", () => {
    fetch("?v-r=routeinfo").then(async (resp) => resp.json()).then((json) => {
      viewsSignal.value = json;
    }).catch((e) => {
      console.error("Failed to fetch route info", e);
    });
  });
}
export {
  RouterConfigurationBuilder,
  createMenuItems,
  createRoute,
  extendModule,
  useViewConfig,
  viewsSignal
};
//# sourceMappingURL=@vaadin_hilla-file-router_runtime__js.js.map
