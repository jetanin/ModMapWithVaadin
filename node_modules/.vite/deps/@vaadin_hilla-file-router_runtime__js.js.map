{
  "version": 3,
  "sources": ["file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/createRoute.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/ProtectedRoute.tsx", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/useAuth.tsx", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/react-auth/src/index.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/RouterConfigurationBuilder.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/shared/convertComponentNameToTitle.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/shared/transformTree.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/useViewConfig.ts", "file:///opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/createMenuItems.ts"],
  "sourcesContent": ["import type { AgnosticRoute, Module, ViewConfig } from '../types.js';\n\n/**\n * Extends a router module's config with additional properties. The original\n * module config is preferred over the extension.\n *\n * @param module - The module to extend.\n * @param config - The extension config.\n * @returns\n */\nexport function extendModule(module: Module | null, config?: ViewConfig): Module {\n  return {\n    ...module,\n    config: {\n      ...config,\n      ...(module?.config as ViewConfig),\n    },\n  };\n}\n\n/**\n * Create a single framework-agnostic route object. Later, it can be transformed into a framework-specific route object,\n * e.g., the one used by React Router.\n *\n * @param path - A route path segment.\n * @param children - An array of child routes.\n *\n * @returns A framework-agnostic route object.\n */\nexport function createRoute(path: string, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(path: string, module: Module, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(\n  path: string,\n  moduleOrChildren?: Module | readonly AgnosticRoute[],\n  children?: readonly AgnosticRoute[],\n): AgnosticRoute {\n  let module: Module | undefined;\n  if (Array.isArray(moduleOrChildren)) {\n    // eslint-disable-next-line no-param-reassign\n    children = moduleOrChildren;\n  } else {\n    module = moduleOrChildren as Module | undefined;\n  }\n\n  return {\n    path,\n    module,\n    children,\n  };\n}\n", "import { useContext, type JSX } from 'react';\nimport type { RouteObject } from 'react-router';\nimport { type IndexRouteObject, Navigate, type NonIndexRouteObject, useLocation } from 'react-router';\nimport { type AccessProps, AuthContext } from './useAuth.js';\n\ntype CustomMetadata = Record<string, any>;\n\ntype HandleWithAuth = Readonly<{ handle?: AccessProps & CustomMetadata }>;\n\ntype Override<T, E> = E & Omit<T, keyof E>;\n\ntype IndexRouteObjectWithAuth = Override<IndexRouteObject, HandleWithAuth>;\ntype NonIndexRouteObjectWithAuth = Override<\n  Override<NonIndexRouteObject, HandleWithAuth>,\n  {\n    children?: RouteObjectWithAuth[];\n  }\n>;\nexport type RouteObjectWithAuth = IndexRouteObjectWithAuth | NonIndexRouteObjectWithAuth;\n\ninterface ProtectedRouteProps {\n  redirectPath: string;\n  access: AccessProps;\n  element: JSX.Element;\n}\n\nfunction ProtectedRoute({ redirectPath, access, element }: ProtectedRouteProps): JSX.Element | null {\n  const {\n    state: { initializing, loading },\n    hasAccess,\n  } = useContext(AuthContext);\n\n  const location = useLocation();\n\n  if (initializing || loading) {\n    return <div></div>;\n  }\n\n  if (!hasAccess(access)) {\n    return <Navigate to={redirectPath} state={{ from: location }} replace />;\n  }\n\n  return element;\n}\n\nProtectedRoute.type = 'ProtectedRoute'; // This is for copilot to recognize this\n\nfunction* traverse<T extends RouteObject>(routes: T[]): Generator<T, undefined, undefined> {\n  for (const route of routes) {\n    yield route;\n    if (route.children) {\n      yield* traverse(route.children as T[]);\n    }\n  }\n}\n\n/**\n * Adds protection to a single route that requires authentication.\n * These route should contain the {@link AccessProps.loginRequired} and/or\n * {@link AccessProps.rolesAllowed} property to get the protection. Route\n * without that property won't be protected.\n *\n * @param route - the route to protect\n * @param redirectPath - the path to redirect to if the route is protected\n * and the user is not authenticated.\n * @returns the route extended with protection if needed\n */\nexport function protectRoute(route: RouteObjectWithAuth, redirectPath: string = '/login'): RouteObjectWithAuth {\n  const { handle } = route;\n  const requiresAuth = handle?.loginRequired ?? handle?.requiresLogin ?? handle?.rolesAllowed?.length;\n\n  if (requiresAuth) {\n    route.element = (\n      <ProtectedRoute\n        redirectPath={redirectPath}\n        access={handle as AccessProps}\n        element={route.element as JSX.Element}\n      />\n    );\n  }\n\n  return route;\n}\n\n/**\n * Protects a route tree with {@link protectRoute} function.\n *\n * @param routes - the roots of the route tree that requires protection.\n * @param redirectPath - the path to redirect to if the route is\n * protected and the user is not authenticated.\n * @returns the protected route tree\n */\nexport function protectRoutes(routes: RouteObjectWithAuth[], redirectPath: string = '/login'): RouteObjectWithAuth[] {\n  for (const route of traverse(routes)) {\n    protectRoute(route, redirectPath);\n  }\n\n  return routes;\n}\n", "import {\n  login as _login,\n  type LoginOptions,\n  type LoginResult,\n  logout as _logout,\n  type LogoutOptions,\n  UnauthorizedResponseError,\n} from '@vaadin/hilla-frontend';\nimport { type Context, createContext, type Dispatch, useContext, useEffect, useReducer } from 'react';\n\ntype LoginFunction = (username: string, password: string, options?: LoginOptions) => Promise<LoginResult>;\ntype LogoutFunction = () => Promise<void>;\n\nconst LOGIN_FETCH = 'LOGIN_FETCH';\nconst LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nconst LOGIN_FAILURE = 'LOGIN_FAILURE';\nconst LOGOUT = 'LOGOUT';\n\n/**\n * The type of the function that is used to get the authenticated user.\n */\nexport type GetUserFn<TUser> = () => Promise<TUser | undefined>;\n\ntype AuthState<TUser> = Readonly<{\n  initializing: boolean;\n  loading: boolean;\n  user?: TUser;\n  error?: string;\n  getAuthenticatedUser?: GetUserFn<TUser>;\n}>;\n\ntype LoginFetchAction = Readonly<{\n  type: typeof LOGIN_FETCH;\n}>;\n\ntype LoginSuccessAction = Readonly<{\n  user: unknown;\n  type: typeof LOGIN_SUCCESS;\n}>;\n\ntype LoginFailureAction = Readonly<{\n  error: string;\n  type: typeof LOGIN_FAILURE;\n}>;\n\ntype LoginActions = LoginFailureAction | LoginFetchAction | LoginSuccessAction;\n\ntype LogoutAction = Readonly<{\n  type: typeof LOGOUT;\n}>;\n\nfunction createAuthenticateThunk<TUser>(dispatch: Dispatch<LoginActions>, getAuthenticatedUser: GetUserFn<TUser>) {\n  async function authenticate() {\n    dispatch({ type: LOGIN_FETCH });\n\n    // Get user info from endpoint\n    const user = await getAuthenticatedUser().catch((error: unknown) => {\n      if (error instanceof UnauthorizedResponseError) {\n        // 401 response: the user is not authenticated\n        return undefined;\n      }\n\n      throw error;\n    });\n\n    if (user) {\n      dispatch({\n        user,\n        type: LOGIN_SUCCESS,\n      });\n    } else {\n      dispatch({\n        error: 'Not authenticated',\n        type: LOGIN_FAILURE,\n      });\n    }\n  }\n\n  return authenticate;\n}\n\nfunction createUnauthenticateThunk(dispatch: Dispatch<LogoutAction>) {\n  return () => {\n    dispatch({ type: LOGOUT });\n  };\n}\n\nconst initialState: AuthState<unknown> = {\n  initializing: true,\n  loading: false,\n};\n\nfunction reducer(state: AuthState<unknown>, action: LoginActions | LogoutAction) {\n  switch (action.type) {\n    case LOGIN_FETCH:\n      return {\n        initializing: false,\n        loading: true,\n      };\n    case LOGIN_SUCCESS:\n      return {\n        initializing: false,\n        loading: false,\n        user: action.user,\n      };\n    case LOGIN_FAILURE:\n      return {\n        initializing: false,\n        loading: false,\n        error: action.error,\n      };\n    case LOGOUT:\n      return { initializing: false, loading: false };\n    default:\n      return state;\n  }\n}\n\n/**\n * The properties that can be used to control access to a route.\n * They can be added to the route type handler as properties.\n */\nexport type AccessProps = Readonly<{\n  /**\n   * If true, the user must be logged in to access the route.\n   */\n  loginRequired?: boolean;\n  /**\n   * If true, the user must be logged in to access the route.\n   *\n   * @deprecated Use `loginRequired` instead.\n   */\n  requiresLogin?: boolean;\n  /**\n   * The list of roles that are allowed to access the route.\n   */\n  rolesAllowed?: readonly [string, ...string[]];\n}>;\n\n/**\n * The type of the authentication hook.\n */\nexport type Authentication<TUser> = Readonly<{\n  state: AuthState<TUser>;\n  login: LoginFunction;\n  logout: LogoutFunction;\n  hasAccess(accessProps: AccessProps): boolean;\n}>;\n\n/**\n * The hook that can be used to get the authentication state.\n * It returns the state of the authentication.\n */\nexport const AuthContext: Context<Authentication<unknown>> = createContext<Authentication<unknown>>({\n  state: initialState,\n  login() {\n    throw new Error('AuthContext not initialized');\n  },\n  logout() {\n    throw new Error('AuthContext not initialized');\n  },\n  hasAccess(): boolean {\n    throw new Error('AuthContext not initialized');\n  },\n});\n\ninterface AuthConfig<TUser> {\n  getRoles?(user: TUser): readonly string[];\n}\n\ninterface AuthProviderProps<TUser> extends React.PropsWithChildren {\n  getAuthenticatedUser: GetUserFn<TUser>;\n  config?: AuthConfig<TUser>;\n}\n\ninterface UserWithRoles {\n  roles?: any;\n}\n\nconst getDefaultRoles = (user: unknown) => {\n  const userWithRoles = user as UserWithRoles;\n  return Array.isArray(userWithRoles.roles) ? userWithRoles.roles : [];\n};\n\nfunction AuthProvider<TUser>({ children, getAuthenticatedUser, config }: AuthProviderProps<TUser>) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const authenticate = createAuthenticateThunk(dispatch, getAuthenticatedUser);\n  const unauthenticate = createUnauthenticateThunk(dispatch);\n\n  async function login(username: string, password: string, options?: LoginOptions): Promise<LoginResult> {\n    const result = await _login(username, password, options);\n\n    if (!result.error) {\n      await authenticate();\n    }\n\n    return result;\n  }\n\n  async function logout(options?: LogoutOptions): Promise<void> {\n    await _logout(options);\n    unauthenticate();\n  }\n\n  function hasAccess({ loginRequired, requiresLogin, rolesAllowed }: AccessProps): boolean {\n    const requiresAuth = loginRequired ?? requiresLogin ?? rolesAllowed;\n    if (!requiresAuth) {\n      return true;\n    }\n\n    if (!state.user) {\n      return false;\n    }\n\n    if (rolesAllowed) {\n      const userRoles = config?.getRoles ? config.getRoles(state.user as TUser) : getDefaultRoles(state.user);\n      return rolesAllowed.some((allowedRole) => userRoles.includes(allowedRole));\n    }\n\n    return true;\n  }\n\n  useEffect(() => {\n    authenticate().catch(() => {\n      // Do nothing\n    });\n  }, []);\n\n  const auth = {\n    state,\n    login,\n    logout,\n    hasAccess,\n  };\n\n  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;\n}\n\nexport type AuthHook<TUser> = () => Authentication<TUser>;\n\n/**\n * The hook that can be used to authenticate the user.\n * It returns the state of the authentication and the functions\n * to authenticate and unauthenticate the user.\n */\nfunction useAuth<TUser>(): Authentication<TUser> {\n  return useContext(AuthContext) as Authentication<TUser>;\n}\n\ninterface AuthModule<TUser> {\n  AuthProvider: React.FC<React.PropsWithChildren>;\n  useAuth: AuthHook<TUser>;\n}\n\nexport function configureAuth<TUser>(\n  getAuthenticatedUser: GetUserFn<TUser>,\n  config?: AuthConfig<TUser>,\n): AuthModule<TUser> {\n  function PreconfiguredAuthProvider({ children }: React.PropsWithChildren) {\n    return (\n      <AuthProvider<TUser> getAuthenticatedUser={getAuthenticatedUser} config={config}>\n        {children}\n      </AuthProvider>\n    );\n  }\n\n  return {\n    AuthProvider: PreconfiguredAuthProvider,\n    useAuth: useAuth as AuthHook<TUser>,\n  };\n}\n", "export * from './ProtectedRoute.js';\nexport * from './useAuth.js';\n\n// @ts-expect-error: esbuild injection\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n((feature, vaadinObj = (window.Vaadin ??= {})) => {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `@vaadin/hilla-react-auth/${feature}` : '@vaadin/hilla-react-auth',\n    version: '24.7.2',\n  });\n})();\n", "/* eslint-disable @typescript-eslint/consistent-type-assertions */\nimport { protectRoute } from '@vaadin/hilla-react-auth';\nimport { type ComponentType, createElement } from 'react';\nimport { createBrowserRouter, type IndexRouteObject, type NonIndexRouteObject, type RouteObject } from 'react-router';\nimport { convertComponentNameToTitle } from '../shared/convertComponentNameToTitle.js';\nimport { transformTree } from '../shared/transformTree.js';\nimport type {\n  AgnosticRoute,\n  Module,\n  RouteModule,\n  RouterBuildOptions,\n  RouterConfiguration,\n  ViewConfig,\n} from '../types.js';\n\ninterface RouteBase {\n  path?: string;\n  children?: readonly this[];\n}\n\nfunction isReactRouteModule(module: Module): module is RouteModule<ComponentType> {\n  return (\n    ('default' in module && typeof module.default === 'function') ||\n    ('config' in module && typeof module.config === 'object')\n  );\n}\n\nexport type RouteList = readonly RouteObject[];\nexport type WritableRouteList = RouteObject[];\n\nexport type RouteTransformerOptions<T> = Readonly<{\n  children?: RouteList;\n  original?: RouteObject;\n  overriding?: T;\n  dupe: boolean;\n}>;\n\nexport type RouteTransformer<T> = (opts: RouteTransformerOptions<T>) => RouteObject | undefined;\n\ntype RoutesModifier = (routes: RouteList | undefined) => RouteList | undefined;\n\nfunction createRouteKey<T extends RouteBase>(route: T): string {\n  return `${route.path ?? ''}-${route.children ? 'n' : 'i'}`;\n}\n\nenum RouteHandleFlags {\n  FLOW_LAYOUT = 'flowLayout',\n  IGNORE_FALLBACK = 'ignoreFallback',\n  SKIP_LAYOUTS = 'skipLayouts',\n}\n\nfunction getRouteHandleFlag<T extends RouteHandleFlags>(route: RouteObject, flag: T): boolean | undefined {\n  if (typeof route.handle === 'object' && flag in route.handle) {\n    return (route.handle as Record<T, boolean>)[flag];\n  }\n\n  return undefined;\n}\n\n/**\n * A builder for creating a Vaadin-specific router for React with\n * authentication and server routes support.\n */\nexport class RouterConfigurationBuilder {\n  readonly #modifiers: RoutesModifier[] = [];\n\n  /**\n   * Adds the given routes to the current list of routes. All the routes are\n   * deeply merged to preserve the path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withReactRoutes(routes: RouteList): this {\n    return this.update(routes);\n  }\n\n  /**\n   * Adds the given file routes to the current list of routes. All the routes\n   * are transformed to React RouterObjects and deeply merged to preserve the\n   * path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withFileRoutes(routes: readonly AgnosticRoute[]): this {\n    return this.update(routes, ({ original, overriding: added, children }) => {\n      if (added) {\n        const { module, path, flowLayout } = added;\n        if (module && !isReactRouteModule(module)) {\n          throw new Error(\n            `The module for the \"${path}\" section doesn't have the React component exported by default or a ViewConfig object exported as \"config\"`,\n          );\n        }\n\n        const element = module?.default ? createElement(module.default) : undefined;\n        const handle = {\n          ...module?.config,\n          title: module?.config?.title ?? convertComponentNameToTitle(module?.default),\n          flowLayout: module?.config?.flowLayout ?? flowLayout,\n        };\n\n        if (path === '' && !children) {\n          return {\n            ...original,\n            element,\n            handle,\n            index: true,\n          } as IndexRouteObject;\n        }\n\n        return {\n          ...original,\n          path: module?.config?.route ?? path,\n          element,\n          children,\n          handle,\n        } as NonIndexRouteObject;\n      }\n\n      return original;\n    });\n  }\n\n  /**\n   * Adds the given server route element to each branch of the current list of\n   * routes.\n   *\n   * @param component - The React component to add to each branch of the\n   * current list of routes.\n   * @param config - An optional configuration that will be applied to\n   * each fallback component.\n   */\n  withFallback(component: ComponentType, config?: ViewConfig): this {\n    this.withLayout(component);\n\n    // Fallback adds two routes, so that the index (empty path) has a fallback too\n    const fallbackRoutes: RouteList = [\n      { path: '*', element: createElement(component), handle: config },\n      { index: true, element: createElement(component), handle: config },\n    ];\n\n    this.update(fallbackRoutes, ({ original, overriding: added, children, dupe }) => {\n      if (original && !getRouteHandleFlag(original, RouteHandleFlags.IGNORE_FALLBACK) && !dupe) {\n        if (!children) {\n          return original;\n        }\n\n        const _fallback = [...fallbackRoutes];\n\n        if (children.some(({ path }) => path === '*')) {\n          _fallback.shift();\n        }\n\n        if (children.some(({ index: i, path }) => i ?? path?.includes('?'))) {\n          _fallback.pop();\n        }\n\n        return {\n          ...original,\n          children: [...children, ..._fallback],\n        } as RouteObject;\n      }\n\n      return added!;\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.\n   *\n   * @param layoutComponent - layout component to use, usually Flow\n   */\n  withLayout(layoutComponent: ComponentType): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        server: T;\n        client: T;\n        ambivalent: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto three separate lists:\n        // - A list of server routes\n        // - A list of client routes\n        // - A list of routes which will be moved to either server or client\n        // list. It depends on the parent route.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            const { server, client, ambivalent } = next(route.children ?? []);\n\n            const flag = getRouteHandleFlag(route, RouteHandleFlags.FLOW_LAYOUT);\n\n            // If the route has `flowLayout` flag explicitly enabled, it goes to\n            // the server list. The children are also affected by the flag\n            // unless they have it explicitly disabled.\n            if (flag === true) {\n              lists.server.push({\n                ...route,\n                children: route.children ? [...server, ...ambivalent] : undefined,\n              } as RouteObject);\n            } else if (server.length > 0) {\n              // Even if the route doesn't have the flag, it goes to the server\n              // list if any of the children has the flag enabled.\n              lists.server.push({\n                ...route,\n                children: route.children ? server : undefined,\n              } as RouteObject);\n            }\n\n            // If the route has `flowLayout` flag explicitly disabled, it goes\n            // to the client list. The route children are not affected by the\n            // flag.\n            if (flag === false || client.length > 0) {\n              lists.client.push({\n                ...route,\n                children: route.children ? client : undefined,\n              } as RouteObject);\n            }\n\n            // The route without the flag go to the `default` list. Then it will\n            // be moved to either server or client list based on the parent\n            // route.\n            if (\n              flag === undefined &&\n              (lists.server.every(({ path }) => path !== route.path) || ambivalent.length > 0)\n            ) {\n              lists.ambivalent.push({\n                ...route,\n                children: route.children ? ambivalent : undefined,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { server: [], client: [], ambivalent: [] },\n        ),\n      );\n\n      return [\n        ...(result.server.length\n          ? [\n              // The server routes are wrapped with the route that has a layout\n              // element. It also has the `IGNORE_FALLBACK` flag to remove the\n              // fallback route from reach.\n              {\n                element: createElement(layoutComponent),\n                children: result.server as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        // The client routes are preserved without wrapping.\n        ...result.client,\n        // The ambivalent routes are considered as client routes.\n        ...result.ambivalent,\n      ];\n    });\n\n    return this;\n  }\n\n  /**\n   * Protects all the routes that require authentication. For more details see\n   * {@link @vaadin/hilla-react-auth#protectRoutes} function.\n   *\n   * @param redirectPath - the path to redirect to if the route is protected\n   * and the user is not authenticated.\n   */\n  protect(redirectPath?: string): this {\n    this.update(undefined, ({ original: route, children }) => {\n      const finalRoute = protectRoute(route!, redirectPath);\n      finalRoute.children = children as RouteObject[] | undefined;\n      return finalRoute;\n    });\n\n    return this;\n  }\n\n  /**\n   * Deeply updates the current list of routes with the given routes merging\n   * them in process.\n   *\n   * @param routes - A list of routes to merge with the current list.\n   * @param callback - A callback to transform the routes during the merge.\n   */\n  update(routes: undefined, callback: RouteTransformer<undefined>): this;\n  update<T extends RouteBase>(routes: readonly T[], callback?: RouteTransformer<T>): this;\n  update<T extends RouteBase>(\n    routes: readonly T[] | undefined,\n    callback: RouteTransformer<T | undefined> = ({ original, overriding, children }) =>\n      ({\n        ...original,\n        ...overriding,\n        children,\n      }) as RouteObject,\n  ): this {\n    this.#modifiers.push((existingRoutes) =>\n      // Going through the existing and added list of routes.\n      transformTree<readonly [RouteList | undefined, readonly T[] | undefined], RouteList | undefined>(\n        [existingRoutes, routes],\n        null,\n        ([original, added], next) => {\n          if (original && added) {\n            // If we have both original and added routes, we have to merge them.\n            const final: Array<RouteObject | undefined> = [];\n            const pathKeys = new Set([...original.map(createRouteKey), ...added.map(createRouteKey)]);\n\n            for (const pathKey of pathKeys) {\n              // We can have multiple routes with the same path, so we have to\n              // consider all of them.\n              const originalRoutes = original.filter((r) => createRouteKey(r) === pathKey);\n              // We can have only one route with the same path in the added list.\n              const addedRoutes = added.filter((r) => createRouteKey(r) === pathKey);\n\n              if (addedRoutes.length > 1) {\n                throw new Error('Adding multiple routes with the same path is not allowed');\n              }\n\n              const addedRoute = addedRoutes[0] as T | undefined;\n\n              if (originalRoutes.length > 0 && addedRoute) {\n                // In case we have both original and added routes, we run\n                // the callback for each original route in pair with the added\n                // route. To make the difference, we flag all the routes except\n                // the last one as `dupe`.\n                //\n                // Why the last one is not `dupe`? According to the\n                // `react-router` logic, the last route is the fallback for all\n                // routes with the same path. So, if we apply callback to it,\n                // we implicitly apply it to all other routes with the same\n                // path.\n                //\n                // In case this logic doesn't work, the user can apply the\n                // callback without considering the `dupe` flag.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      overriding: addedRoute,\n                      children: next([originalRoutes[i].children, addedRoute.children]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else if (originalRoutes.length > 0) {\n                // In case we don't have the added route with the path being\n                // processed, we run the callback for each original route.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      children: next([originalRoutes[i].children, undefined]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else {\n                // In case we don't have the original route with the path being\n                // processed, we run the callback for only the added route.\n                const result = callback({\n                  overriding: addedRoute,\n                  children: next([undefined, addedRoute!.children]),\n                  dupe: false,\n                });\n\n                if (result) {\n                  final.push(result);\n                }\n              }\n            }\n\n            return final.filter((r) => r != null);\n          } else if (original) {\n            // If we have only original routes, we run the callback for each\n            // original route.\n            return original\n              .map((route) =>\n                callback({\n                  original: route,\n                  children: next([route.children, undefined]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          } else if (added) {\n            // If we have only added routes, we run the callback for each added\n            // route.\n            return added\n              .map((route) =>\n                callback({\n                  overriding: route,\n                  children: next([undefined, route.children]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          }\n\n          return undefined;\n        },\n      ),\n    );\n    return this;\n  }\n\n  /**\n   * Builds the router with the current list of routes.\n   */\n  build(options?: RouterBuildOptions): RouterConfiguration {\n    this.#withLayoutSkipping();\n    const routes = this.#modifiers.reduce<RouteList | undefined>((acc, mod) => mod(acc) ?? acc, undefined) ?? [];\n\n    return {\n      routes,\n      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options }),\n    };\n  }\n\n  #withLayoutSkipping(): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        skipped: T;\n        regular: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto two separate lists.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            // If the route has `skipLayout` flag, it goes to the `skipped` list.\n            if (getRouteHandleFlag(route, RouteHandleFlags.SKIP_LAYOUTS)) {\n              lists.skipped.push(route);\n              return lists;\n            }\n\n            // If the route is leaf, it goes to the `regular` list.\n            if (!route.children?.length) {\n              lists.regular.push(route);\n              return lists;\n            }\n\n            // As of children, we have to split them into two lists as well.\n            const { skipped, regular } = next(route.children ?? []);\n\n            // If we have `skipped` list of children, we have to remove the\n            // `element` property of the router to prevent the layout from\n            // rendering. Then, we add the current route to the `skipped` list.\n            if (skipped.length > 0) {\n              const { element, ...rest } = route;\n\n              lists.skipped.push({\n                ...rest,\n                children: skipped,\n              } as RouteObject);\n            }\n\n            // In case of `regular` children, we just add the current route to\n            // the `regular` list if there are any children.\n            if (regular.length > 0) {\n              lists.regular.push({\n                ...route,\n                children: regular,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { skipped: [], regular: [] },\n        ),\n      );\n\n      // We don't need a fallback for the skipped routes, so we have to wrap\n      // them with the route with the `IGNORE_FALLBACK` flag.\n      return [\n        ...(result.skipped.length\n          ? [\n              {\n                children: result.skipped as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        ...result.regular,\n      ];\n    });\n\n    return this;\n  }\n}\n", "const viewPattern = /view/giu;\nconst upperCaseSplitPattern = /(?=[A-Z])/gu;\n\n/**\n * Converts the name of the component to a page title.\n *\n * @param component - The component to convert the name from.\n *\n * @returns The page title.\n */\nexport function convertComponentNameToTitle(component: unknown): string {\n  let name: string;\n\n  if (\n    component &&\n    (typeof component === 'object' || typeof component === 'function') &&\n    'name' in component &&\n    typeof component.name === 'string'\n  ) {\n    ({ name } = component);\n  } else {\n    name = String(component);\n  }\n\n  return name.replace(viewPattern, '').split(upperCaseSplitPattern).join(' ');\n}\n", "export function transformTree<T extends readonly unknown[], U, C extends object | null = null>(\n  nodes: T,\n  context: C,\n  transformer: (nodes: T, next: (nodes: T, ctx?: C) => U, context: C) => U,\n): U {\n  return transformer(nodes, (n, ctx = context) => transformTree(n, ctx, transformer), context);\n}\n", "import type { UIMatch } from 'react-router';\nimport { useMatches } from 'react-router';\nimport type { ViewConfig } from '../types.js';\n\n/**\n * Hook to return the {@link ViewConfig} for the current route.\n */\nexport function useViewConfig<M extends ViewConfig>(): M | undefined {\n  const matches = useMatches() as ReadonlyArray<UIMatch<unknown, M>>;\n  return matches[matches.length - 1]?.handle;\n}\n", "/// <reference types=\"vite/client\" />\nimport { type Signal, signal } from '@vaadin/hilla-react-signals';\nimport type { VaadinWindow } from '../shared/internal.js';\nimport type { MenuItem, ViewConfig } from '../types.js';\n\nexport const viewsSignal: Signal<Readonly<Record<string, Readonly<ViewConfig>>> | undefined> = signal(\n  (window as VaadinWindow).Vaadin?.views,\n);\n\nfunction isExcluded(value: ViewConfig): boolean {\n  return !!value.menu?.exclude;\n}\n\nfunction hasVariablePathSegment(path: string): boolean {\n  return path.split('/').some((segment) => segment.startsWith(':'));\n}\n\n/**\n * Creates menu items from the views provided by the server. The views are sorted according to the\n * {@link ViewConfig.menu.order}, filtered out if they are explicitly excluded via {@link ViewConfig.menu.exclude}.\n * Note that views with no order are put below views with an order. Ties are resolved based on the path string\n * comparison.\n *\n * @returns A list of menu items.\n */\nexport function createMenuItems(): readonly MenuItem[] {\n  // @ts-expect-error: esbuild injection\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  ((feature, vaadinObj = (window.Vaadin ??= {})) => {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `@vaadin/hilla-file-router/${feature}` : '@vaadin/hilla-file-router',\n    version: '24.7.2',\n  });\n})('createMenuItems', (window as VaadinWindow).Vaadin);\n  const collator = new Intl.Collator('en-US');\n  if (!viewsSignal.value) {\n    return [];\n  }\n\n  const views = Object.entries(viewsSignal.value);\n\n  return (\n    views\n      // Filter out the views that are explicitly excluded from the menu.\n      .filter(([path, value]) => !isExcluded(value) && !hasVariablePathSegment(path))\n      // Map the views to menu items.\n      .map(([path, config]) => ({\n        to: path,\n        icon: config.menu?.icon,\n        title: config.menu?.title ?? config.title,\n        order: config.menu?.order,\n      }))\n      // Sort views according to the order specified in the view configuration.\n      .sort((menuA, menuB) => {\n        const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);\n        return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);\n      })\n  );\n}\n\nif (import.meta.hot) {\n  import.meta.hot.on('fs-route-update', () => {\n    fetch('?v-r=routeinfo')\n      .then(async (resp) => resp.json())\n      .then((json) => {\n        viewsSignal.value = json;\n      })\n      .catch((e: unknown) => {\n        console.error('Failed to fetch route info', e);\n      });\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAUO,SAAS,aAAaA,QAAuBC,QAA6B;AAC/E,SAAO;IACL,GAAG;IACH,QAAQ;MACN,GAAG;MACH,GAAI,iCAAQ;IACb;EACF;AACF;AAaM,SAAS,YACdC,MACAC,kBACAC,UACe;AACf,MAAIC;AACJ,MAAI,MAAM,QAAQ,gBAAA,GAAmB;AAEnC,eAAW;EACZ,OAAM;AACL,aAAS;EACV;AAED,SAAO;IACL;IACA;IACA;EACD;AACF;;;ACjDD,IAAAC,gBAAS;;;ACQT,mBAA4E;;AA+E5E,IAAMC,eAAmC;EACvC,cAAc;EACd,SAAS;AACV;AA+DM,IAAMC,kBAAgD,4BAAuC;EAClG,OAAO;EACP,QAAQ;AACN,UAAM,IAAI,MAAM,6BAAA;EACjB;EACD,SAAS;AACP,UAAM,IAAI,MAAM,6BAAA;EACjB;EACD,YAAqB;AACnB,UAAM,IAAI,MAAM,6BAAA;EACjB;AACF,CAAA;;;;AD1ID,SAAS,eAAe,EAAE,cAAc,QAAQ,QAAA,GAAoD;AAClG,QAAM,EACJ,OAAO,EAAE,cAAc,QAAA,GACvB,UAAA,QACE,0BAAW,WAAA;AAEf,QAAM,WAAW,YAAA;AAEjB,MAAI,gBAAgB,SAAS;AAC3B,eAAO,oBAAAC;MAAC;;;;EACT;AAED,MAAA,CAAK,UAAU,MAAA,GAAS;AACtB,eAAO,oBAAAA,KAAC,UAAA;MAAS,IAAI;MAAc,OAAO,EAAE,MAAM,SAAU;MAAE,SAAA;;EAC/D;AAED,SAAO;AACR;AAED,eAAe,OAAO;AAsBf,SAAS,aAAaC,OAA4BC,eAAuB,UAA+B;AAnE/G,MAAAC;AAoEE,QAAM,EAAE,OAAA,IAAW;AACnB,QAAM,gBAAe,iCAAQ,mBAAiB,iCAAQ,oBAAiBA,MAAA,iCAAQ,iBAAR,gBAAAA,IAAsB;AAE7F,MAAI,cAAc;AAChB,UAAM,cACJ,oBAAAC,KAAC,gBAAA;MACe;MACd,QAAQ;MACR,SAAS,MAAM;;EAGpB;AAED,SAAO;AACR;;;CE7EA,CAAC,SAAS,YAAa,OAAO,WAAP,OAAO,SAAW,CAAE,OAAM;AAChD,YAAU,kBAAV,UAAU,gBAAkB,CAAE;AAC9B,YAAU,cAAc,KAAK;IAC3B,IAAI,UAAA,4BAAsC,OAAA,KAAY;IACtD,SAAS;EACV,CAAA;AACF,GAAA;;;ACTD,IAAAC,gBAA6B;;;ACF7B,IAAM,cAAc;AACpB,IAAM,wBAAwB;AASvB,SAAS,4BAA4BC,WAA4B;AACtE,MAAIC;AAEJ,MACE,cAAA,OACQ,cAAc,YAAA,OAAmB,cAAc,eACvD,UAAU,aAAA,OACH,UAAU,SAAS,UAC1B;AACA,KAAC,EAAE,KAAA,IAAS;EACb,OAAM;AACL,WAAO,OAAO,SAAA;EACf;AAED,SAAO,KAAK,QAAQ,aAAa,EAAA,EAAI,MAAM,qBAAA,EAAuB,KAAK,GAAA;AACxE;;;ACzBM,SAAS,cACdC,OACAC,SACAC,aACG;AACH,SAAO,YAAY,OAAO,CAAC,GAAG,MAAM,YAAY,cAAc,GAAG,KAAK,WAAA,GAAc,OAAA;AACrF;;;AFcD,SAAS,mBAAmBC,QAAsD;AAChF,SACG,aAAa,UAAA,OAAiB,OAAO,YAAY,cACjD,YAAY,UAAA,OAAiB,OAAO,WAAW;AAEnD;AAgBD,SAAS,eAAoCC,OAAkB;AAC7D,SAAA,GAAU,MAAM,QAAQ,EAAA,IAAM,MAAM,WAAW,MAAM,GAAA;AACtD;AAED,IAAK,mBAAA,SAAAC,mBAAL;AACE,EAAAA,kBAAA,aAAA,IAAA;AACA,EAAAA,kBAAA,iBAAA,IAAA;AACA,EAAAA,kBAAA,cAAA,IAAA;;AACD,EAJI,oBAAA,CAAA,CAAA;AAML,SAAS,mBAA+CC,OAAoBC,MAA8B;AACxG,MAAA,OAAW,MAAM,WAAW,YAAY,QAAQ,MAAM,QAAQ;AAC5D,WAAQ,MAAM,OAA8B,IAAA;EAC7C;AAED,SAAO;AACR;AAxDD;AA8DO,IAAM,6BAAN,MAAiC;EAAjC;;AACIC,mCAA+B,CAAE;;;;;;;;EAQ1C,gBAAgBC,QAAyB;AACvC,WAAO,KAAK,OAAO,MAAA;EACpB;;;;;;;;EASD,eAAeC,QAAwC;AACrD,WAAO,KAAK,OAAO,QAAQ,CAAC,EAAE,UAAU,YAAY,OAAO,SAAA,MAAe;AAnF9E,UAAAC,KAAA;AAoFM,UAAI,OAAO;AACT,cAAM,EAAE,QAAQ,MAAM,WAAA,IAAe;AACrC,YAAI,UAAA,CAAW,mBAAmB,MAAA,GAAS;AACzC,gBAAM,IAAI,MAAA,uBACe,IAAA,4GAAK;QAE/B;AAED,cAAM,WAAU,iCAAQ,eAAU,6BAAc,OAAO,OAAA,IAAW;AAClE,cAAM,SAAS;UACb,GAAG,iCAAQ;UACX,SAAOA,MAAA,iCAAQ,WAAR,gBAAAA,IAAgB,UAAS,4BAA4B,iCAAQ,OAAA;UACpE,cAAY,sCAAQ,WAAR,mBAAgB,eAAc;QAC3C;AAED,YAAI,SAAS,MAAA,CAAO,UAAU;AAC5B,iBAAO;YACL,GAAG;YACH;YACA;YACA,OAAO;UACR;QACF;AAED,eAAO;UACL,GAAG;UACH,QAAM,sCAAQ,WAAR,mBAAgB,UAAS;UAC/B;UACA;UACA;QACD;MACF;AAED,aAAO;IACR,CAAA;EACF;;;;;;;;;;EAWD,aAAaC,WAA0BC,QAA2B;AAChE,SAAK,WAAW,SAAA;AAGhB,UAAMC,iBAA4B,CAChC;MAAE,MAAM;MAAK,aAAS,6BAAc,SAAA;MAAY,QAAQ;IAAQ,GAChE;MAAE,OAAO;MAAM,aAAS,6BAAc,SAAA;MAAY,QAAQ;IAAQ,CACnE;AAED,SAAK,OAAO,gBAAgB,CAAC,EAAE,UAAU,YAAY,OAAO,UAAU,KAAA,MAAW;AAC/E,UAAI,YAAA,CAAa,mBAAmB,UAAU,iBAAiB,eAAA,KAAgB,CAAK,MAAM;AACxF,YAAA,CAAK,UAAU;AACb,iBAAO;QACR;AAED,cAAM,YAAY,CAAC,GAAG,cAAe;AAErC,YAAI,SAAS,KAAK,CAAC,EAAE,KAAA,MAAW,SAAS,GAAA,GAAM;AAC7C,oBAAU,MAAA;QACX;AAED,YAAI,SAAS,KAAK,CAAC,EAAE,OAAO,GAAG,KAAA,MAAW,MAAK,6BAAM,SAAS,KAAI,GAAG;AACnE,oBAAU,IAAA;QACX;AAED,eAAO;UACL,GAAG;UACH,UAAU,CAAC,GAAG,UAAU,GAAG,SAAU;QACtC;MACF;AAED,aAAO;IACR,CAAA;AAED,WAAO;EACR;;;;;;EAOD,WAAWC,iBAAsC;AAC/C,uBAAKP,YAAW,KAAK,CAAC,mBAAmB;AACvC,UAAA,CAAK,gBAAgB;AACnB,eAAO;MACR;AAQD,YAAM,SAAS,cAAiD,gBAAgB,MAAM,CAAC,QAAQ,SAM7F,OAAO,OACL,CAAC,OAAO,UAAU;AAChB,cAAM,EAAE,QAAQ,QAAQ,WAAA,IAAe,KAAK,MAAM,YAAY,CAAE,CAAA;AAEhE,cAAM,OAAO,mBAAmB,OAAO,iBAAiB,WAAA;AAKxD,YAAI,SAAS,MAAM;AACjB,gBAAM,OAAO,KAAK;YAChB,GAAG;YACH,UAAU,MAAM,WAAW,CAAC,GAAG,QAAQ,GAAG,UAAW,IAAG;UACzD,CAAA;QACF,WAAU,OAAO,SAAS,GAAG;AAG5B,gBAAM,OAAO,KAAK;YAChB,GAAG;YACH,UAAU,MAAM,WAAW,SAAS;UACrC,CAAA;QACF;AAKD,YAAI,SAAS,SAAS,OAAO,SAAS,GAAG;AACvC,gBAAM,OAAO,KAAK;YAChB,GAAG;YACH,UAAU,MAAM,WAAW,SAAS;UACrC,CAAA;QACF;AAKD,YACE,SAAS,WACR,MAAM,OAAO,MAAM,CAAC,EAAE,KAAA,MAAW,SAAS,MAAM,IAAA,KAAS,WAAW,SAAS,IAC9E;AACA,gBAAM,WAAW,KAAK;YACpB,GAAG;YACH,UAAU,MAAM,WAAW,aAAa;UACzC,CAAA;QACF;AAED,eAAO;MACR,GACD;QAAE,QAAQ,CAAE;QAAE,QAAQ,CAAE;QAAE,YAAY,CAAE;MAAE,CAAA,CAC3C;AAGH,aAAO;QACL,GAAI,OAAO,OAAO,SACd,CAIE;UACE,aAAS,6BAAc,eAAA;UACvB,UAAU,OAAO;UACjB,QAAQ,EAAA,CACL,iBAAiB,eAAA,GAAkB,KACrC;QACF,CACF,IACD,CAAE;QAEN,GAAG,OAAO;QAEV,GAAG,OAAO;MACX;IACF,CAAA;AAED,WAAO;EACR;;;;;;;;EASD,QAAQQ,cAA6B;AACnC,SAAK,OAAO,QAAW,CAAC,EAAE,UAAU,OAAO,SAAA,MAAe;AACxD,YAAM,aAAa,aAAa,OAAQ,YAAA;AACxC,iBAAW,WAAW;AACtB,aAAO;IACR,CAAA;AAED,WAAO;EACR;EAWD,OACEC,QACAC,WAA4C,CAAC,EAAE,UAAU,YAAY,SAAA,OAClE;IACC,GAAG;IACH,GAAG;IACH;EACD,IACG;AACN,uBAAKV,YAAW,KAAK,CAAC,mBAEpB,cACE,CAAC,gBAAgB,MAAO,GACxB,MACA,CAAC,CAAC,UAAU,KAAA,GAAQ,SAAS;AAC3B,UAAI,YAAY,OAAO;AAErB,cAAMW,QAAwC,CAAE;AAChD,cAAM,WAAW,oBAAI,IAAI,CAAC,GAAG,SAAS,IAAI,cAAA,GAAiB,GAAG,MAAM,IAAI,cAAA,CAAgB,CAAA;AAExF,mBAAW,WAAW,UAAU;AAG9B,gBAAM,iBAAiB,SAAS,OAAO,CAAC,MAAM,eAAe,CAAA,MAAO,OAAA;AAEpE,gBAAM,cAAc,MAAM,OAAO,CAAC,MAAM,eAAe,CAAA,MAAO,OAAA;AAE9D,cAAI,YAAY,SAAS,GAAG;AAC1B,kBAAM,IAAI,MAAM,0DAAA;UACjB;AAED,gBAAM,aAAa,YAAY,CAAA;AAE/B,cAAI,eAAe,SAAS,KAAK,YAAY;AAc3C,qBAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,oBAAM,KACJ,SAAS;gBACP,UAAU,eAAe,CAAA;gBACzB,YAAY;gBACZ,UAAU,KAAK,CAAC,eAAe,CAAA,EAAG,UAAU,WAAW,QAAS,CAAA;gBAChE,MAAM,IAAI,eAAe,SAAS;cACnC,CAAA,KAAK,eAAe,CAAA,CAAA;YAExB;UACF,WAAU,eAAe,SAAS,GAAG;AAGpC,qBAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC9C,oBAAM,KACJ,SAAS;gBACP,UAAU,eAAe,CAAA;gBACzB,UAAU,KAAK,CAAC,eAAe,CAAA,EAAG,UAAU,MAAU,CAAA;gBACtD,MAAM,IAAI,eAAe,SAAS;cACnC,CAAA,KAAK,eAAe,CAAA,CAAA;YAExB;UACF,OAAM;AAGL,kBAAM,SAAS,SAAS;cACtB,YAAY;cACZ,UAAU,KAAK,CAAC,QAAW,WAAY,QAAS,CAAA;cAChD,MAAM;YACP,CAAA;AAED,gBAAI,QAAQ;AACV,oBAAM,KAAK,MAAA;YACZ;UACF;QACF;AAED,eAAO,MAAM,OAAO,CAAC,MAAM,KAAK,IAAA;MACjC,WAAU,UAAU;AAGnB,eAAO,SACJ,IAAI,CAAC,UACJ,SAAS;UACP,UAAU;UACV,UAAU,KAAK,CAAC,MAAM,UAAU,MAAU,CAAA;UAC1C,MAAM;QACP,CAAA,CAAC,EAEH,OAAO,CAAC,MAAM,KAAK,IAAA;MACvB,WAAU,OAAO;AAGhB,eAAO,MACJ,IAAI,CAAC,UACJ,SAAS;UACP,YAAY;UACZ,UAAU,KAAK,CAAC,QAAW,MAAM,QAAS,CAAA;UAC1C,MAAM;QACP,CAAA,CAAC,EAEH,OAAO,CAAC,MAAM,KAAK,IAAA;MACvB;AAED,aAAO;IACR,CAAA,CACF;AAEH,WAAO;EACR;;;;EAKD,MAAMC,SAAmD;AACvD,0BAAKC,8DAAL;AACA,UAAM,SAAS,mBAAKb,YAAW,OAA8B,CAAC,KAAK,QAAQ,IAAI,GAAA,KAAQ,KAAK,MAAA,KAAc,CAAE;AAE5G,WAAO;MACL;MACA,QAAQ,oBAAoB,CAAC,GAAG,MAAO,GAAE;QAAE,UAAU,IAAI,IAAI,SAAS,OAAA,EAAS;QAAU,GAAG;MAAS,CAAA;IACtG;EACF;AA8EF;AArbUA;AADJ;AA0WL,wBAAA,WAA4B;AAC1B,qBAAKA,YAAW,KAAK,CAAC,mBAAmB;AACvC,QAAA,CAAK,gBAAgB;AACnB,aAAO;IACR;AAOD,UAAM,SAAS,cAAiD,gBAAgB,MAAM,CAAC,QAAQ,SAE7F,OAAO,OACL,CAAC,OAAO,UAAU;AAtb5B,UAAAG;AAwbY,UAAI,mBAAmB,OAAO,iBAAiB,YAAA,GAAe;AAC5D,cAAM,QAAQ,KAAK,KAAA;AACnB,eAAO;MACR;AAGD,UAAA,GAAKA,MAAA,MAAM,aAAN,gBAAAA,IAAgB,SAAQ;AAC3B,cAAM,QAAQ,KAAK,KAAA;AACnB,eAAO;MACR;AAGD,YAAM,EAAE,SAAS,QAAA,IAAY,KAAK,MAAM,YAAY,CAAE,CAAA;AAKtD,UAAI,QAAQ,SAAS,GAAG;AACtB,cAAM,EAAE,SAAS,GAAG,KAAA,IAAS;AAE7B,cAAM,QAAQ,KAAK;UACjB,GAAG;UACH,UAAU;QACX,CAAA;MACF;AAID,UAAI,QAAQ,SAAS,GAAG;AACtB,cAAM,QAAQ,KAAK;UACjB,GAAG;UACH,UAAU;QACX,CAAA;MACF;AAED,aAAO;IACR,GACD;MAAE,SAAS,CAAE;MAAE,SAAS,CAAE;IAAE,CAAA,CAC7B;AAKH,WAAO,CACL,GAAI,OAAO,QAAQ,SACf,CACE;MACE,UAAU,OAAO;MACjB,QAAQ,EAAA,CACL,iBAAiB,eAAA,GAAkB,KACrC;IACF,CACF,IACD,CAAE,GACN,GAAG,OAAO,OACX;EACF,CAAA;AAED,SAAO;AACR;;;AG7eI,SAAS,gBAAqD;AANrE,MAAAW;AAOE,QAAM,UAAU,WAAA;AAChB,UAAOA,MAAA,QAAQ,QAAQ,SAAS,CAAA,MAAzB,gBAAAA,IAA6B;AACrC;;;ACTD;AAIO,IAAMC,cAAkF,GAC5F,YAAwB,WAAxB,mBAAgC,KAAA;AAGnC,SAAS,WAAWC,OAA4B;AARhD,MAAAC;AASE,SAAA,CAAA,GAASA,MAAA,MAAM,SAAN,gBAAAA,IAAY;AACtB;AAED,SAAS,uBAAuBC,MAAuB;AACrD,SAAO,KAAK,MAAM,GAAA,EAAK,KAAK,CAAC,YAAY,QAAQ,WAAW,GAAA,CAAI;AACjE;AAUM,SAAS,kBAAuC;AAGrD,GAAC,CAAC,SAAS,YAAa,OAAO,WAAP,OAAO,SAAW,CAAE,OAAM;AAClD,cAAU,kBAAV,UAAU,gBAAkB,CAAE;AAC9B,cAAU,cAAc,KAAK;MAC3B,IAAI,UAAA,6BAAuC,OAAA,KAAY;MACvD,SAAS;IACV,CAAA;EACF,GAAE,mBAAoB,OAAwB,MAAA;AAC7C,QAAM,WAAW,IAAI,KAAK,SAAS,OAAA;AACnC,MAAA,CAAK,YAAY,OAAO;AACtB,WAAO,CAAE;EACV;AAED,QAAM,QAAQ,OAAO,QAAQ,YAAY,KAAA;AAEzC,SACE,MAEG,OAAO,CAAC,CAAC,MAAM,KAAA,MAAM,CAAM,WAAW,KAAA,KAAM,CAAK,uBAAuB,IAAA,CAAK,EAE7E,IAAI,CAAC,CAAC,MAAM,MAAA,MAAO;AA9C1B,QAAAD,KAAA;AA8CgC;MACxB,IAAI;MACJ,OAAMA,MAAA,OAAO,SAAP,gBAAAA,IAAa;MACnB,SAAO,YAAO,SAAP,mBAAa,UAAS,OAAO;MACpC,QAAO,YAAO,SAAP,mBAAa;IACrB;GAAA,EAEA,KAAK,CAAC,OAAO,UAAU;AACtB,UAAM,cAAc,MAAM,SAAS,OAAO,cAAc,MAAM,SAAS,OAAO;AAC9E,WAAO,eAAe,IAAI,aAAa,SAAS,QAAQ,MAAM,IAAI,MAAM,EAAA;EACzE,CAAA;AAEN;AAED,IAAI,YAAY,KAAK;AACnB,cAAY,IAAI,GAAG,mBAAmB,MAAM;AAC1C,UAAM,gBAAA,EACH,KAAK,OAAO,SAAS,KAAK,KAAA,CAAM,EAChC,KAAK,CAAC,SAAS;AACd,kBAAY,QAAQ;IACrB,CAAA,EACA,MAAM,CAACE,MAAe;AACrB,cAAQ,MAAM,8BAA8B,CAAA;IAC7C,CAAA;EACJ,CAAA;AACF;",
  "names": ["module: Module | null", "config?: ViewConfig", "path: string", "moduleOrChildren?: Module | readonly AgnosticRoute[]", "children?: readonly AgnosticRoute[]", "module: Module | undefined", "import_react", "initialState: AuthState<unknown>", "AuthContext: Context<Authentication<unknown>>", "_jsx", "route: RouteObjectWithAuth", "redirectPath: string", "_a", "_jsx", "import_react", "component: unknown", "name: string", "nodes: T", "context: C", "transformer: (nodes: T, next: (nodes: T, ctx?: C) => U, context: C) => U", "module: Module", "route: T", "RouteHandleFlags", "route: RouteObject", "flag: T", "#modifiers", "routes: RouteList", "routes: readonly AgnosticRoute[]", "_a", "component: ComponentType", "config?: ViewConfig", "fallbackRoutes: RouteList", "layoutComponent: ComponentType", "redirectPath?: string", "routes: readonly T[] | undefined", "callback: RouteTransformer<T | undefined>", "final: Array<RouteObject | undefined>", "options?: RouterBuildOptions", "#withLayoutSkipping", "_a", "viewsSignal: Signal<Readonly<Record<string, Readonly<ViewConfig>>> | undefined>", "value: ViewConfig", "_a", "path: string", "e: unknown"]
}
