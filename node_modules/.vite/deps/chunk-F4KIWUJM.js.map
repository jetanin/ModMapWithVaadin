{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@preact/signals-core/src/index.ts", "../../@preact/signals-react/runtime/src/index.ts"],
  "sourcesContent": ["/**\r\n * @license React\r\n * use-sync-external-store-shim.development.js\r\n *\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\"use strict\";\r\n\"production\" !== process.env.NODE_ENV &&\r\n  (function () {\r\n    function is(x, y) {\r\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\r\n    }\r\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\r\n      didWarnOld18Alpha ||\r\n        void 0 === React.startTransition ||\r\n        ((didWarnOld18Alpha = !0),\r\n        console.error(\r\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\r\n        ));\r\n      var value = getSnapshot();\r\n      if (!didWarnUncachedGetSnapshot) {\r\n        var cachedValue = getSnapshot();\r\n        objectIs(value, cachedValue) ||\r\n          (console.error(\r\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\r\n          ),\r\n          (didWarnUncachedGetSnapshot = !0));\r\n      }\r\n      cachedValue = useState({\r\n        inst: { value: value, getSnapshot: getSnapshot }\r\n      });\r\n      var inst = cachedValue[0].inst,\r\n        forceUpdate = cachedValue[1];\r\n      useLayoutEffect(\r\n        function () {\r\n          inst.value = value;\r\n          inst.getSnapshot = getSnapshot;\r\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\r\n        },\r\n        [subscribe, value, getSnapshot]\r\n      );\r\n      useEffect(\r\n        function () {\r\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\r\n          return subscribe(function () {\r\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\r\n          });\r\n        },\r\n        [subscribe]\r\n      );\r\n      useDebugValue(value);\r\n      return value;\r\n    }\r\n    function checkIfSnapshotChanged(inst) {\r\n      var latestGetSnapshot = inst.getSnapshot;\r\n      inst = inst.value;\r\n      try {\r\n        var nextValue = latestGetSnapshot();\r\n        return !objectIs(inst, nextValue);\r\n      } catch (error) {\r\n        return !0;\r\n      }\r\n    }\r\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\r\n      return getSnapshot();\r\n    }\r\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\r\n      \"function\" ===\r\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\r\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\r\n    var React = require(\"react\"),\r\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\r\n      useState = React.useState,\r\n      useEffect = React.useEffect,\r\n      useLayoutEffect = React.useLayoutEffect,\r\n      useDebugValue = React.useDebugValue,\r\n      didWarnOld18Alpha = !1,\r\n      didWarnUncachedGetSnapshot = !1,\r\n      shim =\r\n        \"undefined\" === typeof window ||\r\n        \"undefined\" === typeof window.document ||\r\n        \"undefined\" === typeof window.document.createElement\r\n          ? useSyncExternalStore$1\r\n          : useSyncExternalStore$2;\r\n    exports.useSyncExternalStore =\r\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\r\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\r\n      \"function\" ===\r\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\r\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\r\n  })();\r\n", "'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\r\n} else {\r\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\r\n}\r\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n", "import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n} from \"@preact/signals-core\";\nimport {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t});\n\t}, Empty);\n}\n"],
  "mappings": "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",
  "names": ["x", "y", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "BRAND_SYMBOL", "_refresh", "_unsubscribe", "prev", "next", "subscribe", "fn", "_this", "effect", "prevContext", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "call", "undefined", "_fn", "_globalVersion", "OUTDATED", "err", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "major", "reactVersion", "split", "map", "Number", "Empty", "ReactElemType", "Symbol", "wrapJsx", "jsx", "type", "props", "i", "v", "Signal", "value", "call", "apply", "concat", "slice", "arguments", "currentStore", "symDispose", "dispose", "startComponentEffect", "prevStore", "nextStore", "endEffect", "effect", "_start", "finishComponentEffect", "bind", "_ref2", "finalCleanup", "noop", "emptyEffectStore", "_usage", "_sources", "_callback", "_dispose", "subscribe", "getSnapshot", "f", "_queueMicroTask", "Promise", "prototype", "then", "resolve", "ensureFinalCleanup", "cleanupTrailingStore", "_currentStore", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "_useSignalsImplementation", "storeRef", "useRef", "current", "_ref", "effectInstance", "onChangeNotifyReact", "version", "unsubscribe", "this", "onStoreChange", "undefined", "prevUsage", "thisUsage", "end", "store", "useSyncExternalStore", "Object", "defineProperties", "$$typeof", "configurable", "_ref3", "data", "get", "ref", "useSignals", "usage", "useSignal", "useMemo", "signal", "useComputed", "compute", "$compute", "computed", "useSignalEffect", "cb", "callback"]
}
