import {
  A,
  Button_exports,
  Checkbox_exports,
  ConfirmDialog_exports,
  D,
  DatePicker_exports,
  DateTimePicker_exports,
  Dialog_exports,
  FormLayout_exports,
  GridColumnGroup_exports,
  GridColumn_exports,
  GridSorter_exports,
  Grid_exports,
  Icon_exports,
  IntegerField_exports,
  Item_exports,
  ListBox_exports,
  NumberField_exports,
  O,
  Select_exports,
  SplitLayout_exports,
  T,
  TextArea_exports,
  TextField_exports,
  TimePicker_exports,
  VerticalLayout_exports,
  a,
  e,
  f,
  h,
  k,
  k2,
  m2 as m,
  m3 as m2,
  m4 as m3,
  n,
  n3 as n2,
  o2 as o,
  p,
  p2,
  p3,
  p4,
  r,
  r2,
  t,
  v
} from "./chunk-QTHDJJWA.js";
import "./chunk-3ZHLBPBX.js";
import "./chunk-S44NNMXE.js";
import {
  require_jsx_runtime
} from "./chunk-SKCOSPGW.js";
import {
  EndpointError,
  EndpointValidationError
} from "./chunk-BQPM45KC.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-AVWG52NB.js";
import "./chunk-UJKGNB4G.js";
import {
  require_react
} from "./chunk-IF5A3MEL.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-react-crud/autogrid.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autogrid-column-context.js
var import_react = __toESM(require_react(), 1);
var ColumnContext = (0, import_react.createContext)(null);
var CustomColumnContext = (0, import_react.createContext)(null);

// node_modules/@vaadin/hilla-react-crud/autogrid-renderers.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/locale.js
var import_react2 = __toESM(require_react(), 1);
var LocaleContext = (0, import_react2.createContext)(navigator.language);
function getFormatRegex(format) {
  const sampleDate = new Date(1234, 5 - 1, 6);
  const formattedSample = format.format(sampleDate);
  const pattern = formattedSample.replace("1234", "(?<year>\\d+)").replace("05", "(?<month>\\d+)").replace("5", "(?<month>\\d+)").replace("06", "(?<day>\\d+)").replace("6", "(?<day>\\d+)");
  return new RegExp(pattern, "u");
}
function tryFormatDate(formatter, value) {
  try {
    return value ? formatter.format(new Date(value)) : "";
  } catch {
    return "";
  }
}
var _date, _localTime, _localDateTime, _integer, _decimal, _parsePattern;
var LocaleFormatter = class {
  constructor(locale) {
    __privateAdd(this, _date);
    __privateAdd(this, _localTime);
    __privateAdd(this, _localDateTime);
    __privateAdd(this, _integer);
    __privateAdd(this, _decimal);
    __privateAdd(this, _parsePattern);
    __privateSet(this, _date, new Intl.DateTimeFormat(locale));
    __privateSet(this, _localTime, new Intl.DateTimeFormat(locale, {
      hour: "numeric",
      minute: "numeric"
    }));
    __privateSet(this, _localDateTime, new Intl.DateTimeFormat(locale, {
      day: "numeric",
      month: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "numeric"
    }));
    __privateSet(this, _integer, new Intl.NumberFormat(locale, {
      maximumFractionDigits: 0
    }));
    __privateSet(this, _decimal, new Intl.NumberFormat(locale, {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2
    }));
    __privateSet(this, _parsePattern, getFormatRegex(__privateGet(this, _date)));
  }
  formatDate(value) {
    if (typeof value === "object") {
      const { year, month, day } = value;
      const date = /* @__PURE__ */ new Date();
      date.setFullYear(year, month, day);
      return __privateGet(this, _date).format(date);
    }
    return tryFormatDate(__privateGet(this, _date), value);
  }
  formatLocalTime(value) {
    return tryFormatDate(__privateGet(this, _localTime), `2000-01-01T${value}`);
  }
  formatLocalDateTime(value) {
    return tryFormatDate(__privateGet(this, _localDateTime), value);
  }
  formatInteger(value) {
    return value && Number.isFinite(value) ? __privateGet(this, _integer).format(value) : "";
  }
  formatDecimal(value) {
    return value && Number.isFinite(value) ? __privateGet(this, _decimal).format(value) : "";
  }
  parse(dateString) {
    var _a3, _b2, _c2;
    const match = __privateGet(this, _parsePattern).exec(dateString);
    const year = Number((_a3 = match == null ? void 0 : match.groups) == null ? void 0 : _a3.year);
    const month = Number((_b2 = match == null ? void 0 : match.groups) == null ? void 0 : _b2.month) - 1;
    const day = Number((_c2 = match == null ? void 0 : match.groups) == null ? void 0 : _c2.day);
    const dateInstance = /* @__PURE__ */ new Date();
    dateInstance.setFullYear(year, month, day);
    if (dateInstance.getFullYear() !== year || dateInstance.getMonth() !== month || dateInstance.getDate() !== day) {
      return void 0;
    }
    return { year, month, day };
  }
};
_date = new WeakMap();
_localTime = new WeakMap();
_localDateTime = new WeakMap();
_integer = new WeakMap();
_decimal = new WeakMap();
_parsePattern = new WeakMap();
function useLocaleFormatter() {
  const locale = (0, import_react2.useContext)(LocaleContext);
  return (0, import_react2.useMemo)(() => new LocaleFormatter(locale), [locale]);
}
var defaultDatePickerI18n = new e().i18n;
function useDatePickerI18n() {
  const formatter = useLocaleFormatter();
  return (0, import_react2.useMemo)(() => ({
    ...defaultDatePickerI18n,
    formatDate(value) {
      return formatter.formatDate(value);
    },
    parseDate(value) {
      return formatter.parse(value);
    }
  }), [formatter]);
}
var defaultDateTimePickerI18n = new t().i18n;
function useDateTimePickerI18n() {
  const datePickerI18n = useDatePickerI18n();
  return (0, import_react2.useMemo)(() => ({
    ...defaultDateTimePickerI18n,
    ...datePickerI18n
  }), [datePickerI18n]);
}

// node_modules/@vaadin/hilla-react-crud/util.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
function convertToTitleCase(inputString) {
  const stringWithSpaces = inputString.replace(/_/gu, " ");
  const words = stringWithSpaces.split(" ");
  const titleCaseWords = words.map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
  return titleCaseWords.join(" ");
}
function registerStylesheet(stylesheet) {
  const css4 = Array.from(stylesheet.cssRules).map((rule) => rule.cssText).join("\n");
  const styleTag = document.createElement("style");
  styleTag.textContent = css4;
  document.head.prepend(styleTag);
}
var registeredFeatures = /* @__PURE__ */ new Set();
function useFeatureRegistration(feature) {
  if (registeredFeatures.has(feature)) {
    return;
  }
  registeredFeatures.add(feature);
  ((feature2, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
    vaadinObj.registrations ?? (vaadinObj.registrations = []);
    vaadinObj.registrations.push({
      is: feature2 ? `@vaadin/hilla-react-crud/${feature2}` : "@vaadin/hilla-react-crud",
      version: "24.7.2"
    });
  })(feature);
}
function featureRegistration(Component, feature) {
  return (0, import_react3.forwardRef)((props2, ref) => {
    useFeatureRegistration(feature);
    return (0, import_jsx_runtime.jsx)(Component, { ...props2, ref });
  });
}
function isFilterEmpty(filter) {
  if (filter["@type"] === "and" || filter["@type"] === "or") {
    if (filter.children.length === 0) {
      return true;
    }
    return filter.children.every((child) => isFilterEmpty(child));
  }
  if ("filterValue" in filter) {
    return filter.filterValue === "";
  }
  throw new Error(`Unknown filter type: ${"@type" in filter ? filter["@type"] : JSON.stringify(filter)} `);
}

// node_modules/@vaadin/hilla-react-crud/autogrid-renderers.js
import "@vaadin/vaadin-lumo-styles/vaadin-iconset.js";
function getColumnValue(context, item) {
  const path = context.propertyInfo.name;
  return path.split(".").reduce((obj, property) => obj ? obj[property] : void 0, item);
}
var fontVariantStyle = { fontVariantNumeric: "tabular-nums" };
function AutoGridIntegerRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatInteger(getColumnValue(context, item)) });
}
function AutoGridDecimalRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatDecimal(getColumnValue(context, item)) });
}
function AutoGridEnumRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item) || "";
  return (0, import_jsx_runtime2.jsx)("span", { children: convertToTitleCase(value) });
}
function AutoGridBooleanRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item);
  if (value) {
    return (0, import_jsx_runtime2.jsx)(m, { "aria-label": "false", icon: "lumo:checkmark" });
  }
  return (0, import_jsx_runtime2.jsx)(m, { "aria-label": "true", style: { color: "var(--lumo-secondary-text-color)" }, icon: "lumo:minus" });
}
function AutoGridDateRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatDate(getColumnValue(context, item)) });
}
function AutoGridTimeRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatLocalTime(getColumnValue(context, item)) });
}
function AutoGridDateTimeRenderer({ item }) {
  const formatter = useLocaleFormatter();
  const context = (0, import_react4.useContext)(ColumnContext);
  return (0, import_jsx_runtime2.jsx)("span", { style: fontVariantStyle, children: formatter.formatLocalDateTime(getColumnValue(context, item)) });
}
function AutoGridJsonRenderer({ item }) {
  const context = (0, import_react4.useContext)(ColumnContext);
  const value = getColumnValue(context, item);
  const jsonString = value ? JSON.stringify(value) : "";
  const jsonPreview = jsonString.length > 50 ? `${jsonString.substring(0, 50)}...` : jsonString;
  return (0, import_jsx_runtime2.jsx)("span", { children: jsonPreview });
}
function AutoGridRowNumberRenderer({ model }) {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: model.index + 1 });
}
var FooterContext = (0, import_react4.createContext)(void 0);
function AutoGridFooterItemCountRenderer() {
  const footerContext = (0, import_react4.useContext)(FooterContext);
  const { totalCount, filteredCount, itemCounts, footerCountRenderer: FooterRenderer } = footerContext;
  if (FooterRenderer) {
    return (0, import_jsx_runtime2.jsx)(FooterRenderer, { ...itemCounts });
  }
  let filterCountText;
  if (filteredCount && (itemCounts == null ? void 0 : itemCounts.filteredCount) !== void 0) {
    filterCountText = totalCount && itemCounts.totalCount !== void 0 ? `Showing: ${itemCounts.filteredCount} out of ${itemCounts.totalCount}` : `Showing: ${itemCounts.filteredCount}`;
  } else if (totalCount && (itemCounts == null ? void 0 : itemCounts.totalCount) !== void 0) {
    filterCountText = `Total: ${itemCounts.totalCount}`;
  }
  if (filterCountText) {
    return (0, import_jsx_runtime2.jsx)("p", { children: filterCountText });
  }
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
}

// node_modules/@vaadin/hilla-react-crud/header-filter.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/validator/es/lib/util/assertString.js
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function assertString(input) {
  var isString = typeof input === "string" || input instanceof String;
  if (!isString) {
    var invalidType = _typeof(input);
    if (input === null) invalidType = "null";
    else if (invalidType === "object") invalidType = input.constructor.name;
    throw new TypeError("Expected a string but received a ".concat(invalidType));
  }
}

// node_modules/validator/es/lib/alpha.js
var alpha = {
  "en-US": /^[A-Z]+$/i,
  "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
  "bg-BG": /^[А-Я]+$/i,
  "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[A-ZÆØÅ]+$/i,
  "de-DE": /^[A-ZÄÖÜß]+$/i,
  "el-GR": /^[Α-ώ]+$/i,
  "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
  "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
  "fi-FI": /^[A-ZÅÄÖ]+$/i,
  "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
  "nb-NO": /^[A-ZÆØÅ]+$/i,
  "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[A-ZÆØÅ]+$/i,
  "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
  "ru-RU": /^[А-ЯЁ]+$/i,
  "kk-KZ": /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[A-ZÅÄÖ]+$/i,
  "th-TH": /^[ก-๐\s]+$/i,
  "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
  "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
  "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
  "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
  he: /^[א-ת]+$/,
  fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
  eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
  "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
  "si-LK": /^[\u0D80-\u0DFF]+$/
};
var alphanumeric = {
  "en-US": /^[0-9A-Z]+$/i,
  "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
  "bg-BG": /^[0-9А-Я]+$/i,
  "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
  "da-DK": /^[0-9A-ZÆØÅ]+$/i,
  "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
  "el-GR": /^[0-9Α-ω]+$/i,
  "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
  "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
  "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
  "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
  "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
  "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
  "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
  "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
  "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
  "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
  "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
  "ru-RU": /^[0-9А-ЯЁ]+$/i,
  "kk-KZ": /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
  "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
  "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
  "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
  "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
  "th-TH": /^[ก-๙\s]+$/i,
  "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
  "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
  "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
  "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
  "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
  ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
  he: /^[0-9א-ת]+$/,
  fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
  bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
  eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
  "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
  "si-LK": /^[0-9\u0D80-\u0DFF]+$/
};
var decimal = {
  "en-US": ".",
  ar: "٫"
};
var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
for (i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha["en-US"];
  alphanumeric[locale] = alphanumeric["en-US"];
  decimal[locale] = decimal["en-US"];
}
var locale;
var i;
var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
for (_i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
}
var _locale;
var _i;
var farsiLocales = ["IR", "AF"];
for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
  _locale2 = "fa-".concat(farsiLocales[_i2]);
  alphanumeric[_locale2] = alphanumeric.fa;
  decimal[_locale2] = decimal.ar;
}
var _locale2;
var _i2;
var bengaliLocales = ["BD", "IN"];
for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
  _locale3 = "bn-".concat(bengaliLocales[_i3]);
  alpha[_locale3] = alpha.bn;
  alphanumeric[_locale3] = alphanumeric.bn;
  decimal[_locale3] = decimal["en-US"];
}
var _locale3;
var _i3;
var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
  decimal[dotDecimal[_i4]] = decimal["en-US"];
}
var _i4;
for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
  decimal[commaDecimal[_i5]] = ",";
}
var _i5;
alpha["fr-CA"] = alpha["fr-FR"];
alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
alpha["pt-BR"] = alpha["pt-PT"];
alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
decimal["pt-BR"] = decimal["pt-PT"];
alpha["pl-Pl"] = alpha["pl-PL"];
alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
decimal["pl-Pl"] = decimal["pl-PL"];
alpha["fa-AF"] = alpha.fa;

// node_modules/validator/es/lib/isNumeric.js
var numericNoSymbols = /^[0-9]+$/;
function isNumeric(str, options) {
  assertString(str);
  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }
  return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
}

// node_modules/validator/es/lib/isBoolean.js
var strictBooleans = ["true", "false", "1", "0"];
var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);

// node_modules/validator/es/lib/isIP.js
var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");

// node_modules/validator/es/lib/isFloat.js
var locales = Object.keys(decimal);

// node_modules/@vaadin/hilla-lit-form/Validators.js
var AbstractValidator = class {
  constructor(attrs) {
    Object.defineProperty(this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "invalid"
    });
    Object.defineProperty(this, "impliesRequired", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    if (attrs == null ? void 0 : attrs.message) {
      this.message = attrs.message;
    }
  }
};
var Required = class extends AbstractValidator {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "impliesRequired", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Required"
    });
  }
  validate(value) {
    if (typeof value === "string" || Array.isArray(value)) {
      return value.length > 0;
    }
    if (typeof value === "number") {
      return Number.isFinite(value);
    }
    return value !== void 0;
  }
};
var NumberValidator = class extends AbstractValidator {
  validate(value) {
    const num = Number(value);
    return !isNaN(num) && isFinite(num);
  }
};
var IsNumber = class extends NumberValidator {
  constructor(optional, attrs) {
    super({ message: "must be a number", ...attrs });
    Object.defineProperty(this, "optional", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "IsNumber"
    });
    this.optional = optional;
  }
  validate(value) {
    return this.optional && value == null || super.validate(value);
  }
};
var ValidityStateValidator = class extends AbstractValidator {
  constructor() {
    super();
    Object.defineProperty(this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ValidityStateValidator"
    });
  }
  validate() {
    return false;
  }
};

// node_modules/@vaadin/hilla-lit-form/Models.js
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _ObjectModel_properties;
var _ArrayModel_createItem;
var _ArrayModel_items;
var _g;
var _createEmptyItemValue = Symbol("createEmptyItemValue");
var _parent = Symbol("parent");
var _key = Symbol("key");
var _fromString = Symbol("fromString");
var _validators = Symbol("validators");
var _meta = Symbol("meta");
var _getPropertyModel = Symbol("getPropertyModel");
var _enum = Symbol("enum");
var _items = Symbol("items");
var _optional = Symbol("optional");
function hasFromString(model) {
  return _fromString in model;
}
var modelDetachedParent = { $value$: void 0 };
function createDetachedModel(type) {
  return new type(modelDetachedParent, "$value$", false);
}
var AbstractModel = class {
  static createEmptyValue() {
    return void 0;
  }
  constructor(parent, key, optional, options) {
    Object.defineProperty(this, _a, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _b, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _c, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _d, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _e, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this[_parent] = parent;
    this[_key] = key;
    this[_optional] = optional;
    this[_validators] = (options == null ? void 0 : options.validators) ?? [];
    this[_meta] = (options == null ? void 0 : options.meta) ?? {};
  }
  toString() {
    return String(this.valueOf());
  }
  valueOf() {
    const { value } = getBinderNode(this);
    if (value === void 0) {
      throw new TypeError("Value is undefined");
    }
    return value;
  }
};
_a = _parent, _b = _validators, _c = _meta, _d = _optional, _e = _key;
var PrimitiveModel = class extends AbstractModel {
};
var BooleanModel = class extends PrimitiveModel {
  [_fromString](str) {
    return ["true", "1", "yes"].includes(str.toLowerCase());
  }
};
Object.defineProperty(BooleanModel, "createEmptyValue", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: Boolean
});
var NumberModel = class extends PrimitiveModel {
  static createEmptyValue() {
    return NaN;
  }
  constructor(parent, key, optional, options) {
    const validators = [new IsNumber(optional), ...(options == null ? void 0 : options.validators) ?? []];
    super(parent, key, optional, { ...options, validators });
  }
  [_fromString](str) {
    if (str === "") {
      return void 0;
    }
    return isNumeric(str) ? Number.parseFloat(str) : NaN;
  }
};
var StringModel = class extends PrimitiveModel {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _f, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: String
    });
  }
};
_f = _fromString;
Object.defineProperty(StringModel, "createEmptyValue", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: String
});
var EnumModel = class extends AbstractModel {
  [_fromString](value) {
    return value in this[_enum] ? value : void 0;
  }
};
function* getObjectModelOwnAndParentGetters(model) {
  for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const [name, { get }] of Object.entries(descriptors)) {
      if (get) {
        yield [name, get];
      }
    }
  }
}
function makeObjectEmptyValueCreator(type) {
  const model = createDetachedModel(type);
  return () => {
    const obj = {};
    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {
      const propertyModel = getter.call(model);
      obj[key] = propertyModel[_optional] ? void 0 : propertyModel.constructor.createEmptyValue();
    }
    return obj;
  };
}
var ObjectModel = class extends AbstractModel {
  constructor() {
    super(...arguments);
    _ObjectModel_properties.set(this, {});
  }
  [(_ObjectModel_properties = /* @__PURE__ */ new WeakMap(), _getPropertyModel)](key, init) {
    if (!__classPrivateFieldGet(this, _ObjectModel_properties, "f")[key]) {
      __classPrivateFieldGet(this, _ObjectModel_properties, "f")[key] = init(this, key);
    }
    return __classPrivateFieldGet(this, _ObjectModel_properties, "f")[key];
  }
};
Object.defineProperty(ObjectModel, "createEmptyValue", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: makeObjectEmptyValueCreator(ObjectModel)
});
var ArrayModel = class extends AbstractModel {
  static createEmptyValue() {
    return [];
  }
  constructor(parent, key, optional, createItem, options) {
    super(parent, key, optional, options);
    Object.defineProperty(this, _g, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _ArrayModel_createItem.set(this, void 0);
    _ArrayModel_items.set(this, []);
    __classPrivateFieldSet(this, _ArrayModel_createItem, createItem, "f");
    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue;
  }
  *[(_ArrayModel_createItem = /* @__PURE__ */ new WeakMap(), _ArrayModel_items = /* @__PURE__ */ new WeakMap(), _g = _createEmptyItemValue, _items)]() {
    const values = getBinderNode(this).value ?? [];
    if (values.length !== __classPrivateFieldGet(this, _ArrayModel_items, "f").length) {
      __classPrivateFieldGet(this, _ArrayModel_items, "f").length = values.length;
    }
    for (let i = 0; i < values.length; i++) {
      let item = __classPrivateFieldGet(this, _ArrayModel_items, "f")[i];
      if (!item) {
        item = __classPrivateFieldGet(this, _ArrayModel_createItem, "f").call(this, this, i);
        __classPrivateFieldGet(this, _ArrayModel_items, "f")[i] = item;
      }
      yield item;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this[_items]()) {
      yield getBinderNode(item);
    }
  }
};

// node_modules/@vaadin/hilla-lit-form/Validity.js
var _validity = Symbol("validity");
var defaultValidity = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valueMissing: false,
  valid: true
};

// node_modules/@vaadin/hilla-lit-form/BinderNode.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BinderNode_instances;
var _BinderNode_ownErrors;
var _BinderNode_validators;
var _BinderNode_validityStateValidator;
var _BinderNode_visited;
var _BinderNode_getChildBinderNodes;
var _BinderNode_isArray;
var _BinderNode_isArrayItem;
var _BinderNode_isObject;
var _BinderNode_requestValidationOfDescendants;
var _BinderNode_requestValidationWithAncestors;
var _BinderNode_runOwnValidators;
var _BinderNode_setValueState;
var _a2;
var _updateValidation = Symbol("updateValidation");
var _update = Symbol("update");
var _setErrorsWithDescendants = Symbol("setErrorsWithDescendants");
var _clearValidation = Symbol("clearValidation");
var nodes = /* @__PURE__ */ new WeakMap();
function getBinderNode(model) {
  let node = nodes.get(model);
  if (!node) {
    node = new BinderNode(model);
    nodes.set(model, node);
  }
  return node;
}
function getErrorPropertyName(valueError) {
  return typeof valueError.property === "string" ? valueError.property : getBinderNode(valueError.property).name;
}
function updateObjectOrArrayKey(model, value, key, keyValue) {
  if (model instanceof ObjectModel) {
    return {
      ...value,
      [key]: keyValue
    };
  }
  if (keyValue === void 0) {
    throw new TypeError("Unexpected undefined value");
  }
  if (model instanceof ArrayModel) {
    const array = value.slice();
    array[key] = keyValue;
    return array;
  }
  throw new TypeError(`Unknown model type ${model.constructor.name}`);
}
var CHANGED = new Event("binder-node-changed");
var NotArrayModelError = class extends Error {
  constructor() {
    super("The model does not represent array");
  }
};
var NotArrayItemModelError = class extends Error {
  constructor() {
    super("The model does not represent array item");
  }
};
var defaultArrayItemCache = /* @__PURE__ */ new WeakMap();
var BinderNode = class _BinderNode extends EventTarget {
  constructor(model) {
    super();
    _BinderNode_instances.add(this);
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _a2, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _BinderNode_ownErrors.set(this, void 0);
    _BinderNode_validators.set(this, void 0);
    _BinderNode_validityStateValidator.set(this, void 0);
    _BinderNode_visited.set(this, false);
    this.model = model;
    nodes.set(model, this);
    __classPrivateFieldSet2(this, _BinderNode_validityStateValidator, new ValidityStateValidator(), "f");
    __classPrivateFieldSet2(this, _BinderNode_validators, model[_validators], "f");
    if (this.constructor === _BinderNode) {
      this.initializeValue();
    }
  }
  get binder() {
    var _a3;
    const binder = (_a3 = this.parent) == null ? void 0 : _a3.binder;
    if (!binder) {
      throw new TypeError("BinderNode is detached");
    }
    return binder;
  }
  get defaultValue() {
    const key = this.model[_key];
    const parentDefaultValue = this.parent.defaultValue;
    if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isArrayItem).call(this) && !(key in parentDefaultValue)) {
      if (defaultArrayItemCache.has(this.parent)) {
        return defaultArrayItemCache.get(this.parent);
      }
      const value = this.model.constructor.createEmptyValue();
      defaultArrayItemCache.set(this.parent, value);
      return value;
    }
    return parentDefaultValue[key];
  }
  get dirty() {
    return this.value !== this.defaultValue;
  }
  get errors() {
    return [...Array.from(__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_getChildBinderNodes).call(this), (node) => node.errors).flat(), ...this.ownErrors];
  }
  get invalid() {
    return this.errors.length > 0;
  }
  get name() {
    let { model } = this;
    let name = "";
    while (model[_parent] instanceof AbstractModel) {
      name = `${String(model[_key])}${name ? `.${name}` : ""}`;
      model = model[_parent];
    }
    return name;
  }
  get ownErrors() {
    return __classPrivateFieldGet2(this, _BinderNode_ownErrors, "f") ? __classPrivateFieldGet2(this, _BinderNode_ownErrors, "f") : [];
  }
  get parent() {
    const modelParent = this.model[_parent];
    return modelParent instanceof AbstractModel ? getBinderNode(modelParent) : void 0;
  }
  get required() {
    return __classPrivateFieldGet2(this, _BinderNode_validators, "f").some((validator) => validator.impliesRequired);
  }
  get validators() {
    return __classPrivateFieldGet2(this, _BinderNode_validators, "f");
  }
  set validators(validators) {
    __classPrivateFieldSet2(this, _BinderNode_validators, validators, "f");
    this.dispatchEvent(CHANGED);
  }
  get value() {
    if (!this.parent) {
      return void 0;
    }
    this.initializeValue();
    const key = this.model[_key];
    return this.parent.value[key];
  }
  set value(value) {
    this.initializeValue(true);
    const oldValue = this.value;
    if (value !== oldValue) {
      __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_setValueState).call(this, value, void 0);
      this[_updateValidation]().catch(() => {
      });
    }
  }
  get visited() {
    return __classPrivateFieldGet2(this, _BinderNode_visited, "f");
  }
  set visited(v2) {
    if (__classPrivateFieldGet2(this, _BinderNode_visited, "f") !== v2) {
      __classPrivateFieldSet2(this, _BinderNode_visited, v2, "f");
      this.dispatchEvent(CHANGED);
    }
  }
  addValidator(validator) {
    this.validators = [...__classPrivateFieldGet2(this, _BinderNode_validators, "f"), validator];
    this.dispatchEvent(CHANGED);
  }
  appendItem(item) {
    if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isArray).call(this)) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [...this.value ?? [], itemValueOrEmptyValue];
      const newDefaultValue = [...this.defaultValue ?? [], itemValueOrEmptyValue];
      __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_setValueState).call(this, newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  for(model) {
    const binderNode = getBinderNode(model);
    if (binderNode.binder !== this.binder) {
      throw new Error("Unknown binder");
    }
    return binderNode;
  }
  prependItem(item) {
    if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isArray).call(this)) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [itemValueOrEmptyValue, ...this.value ?? []];
      const newDefaultValue = [itemValueOrEmptyValue, ...this.defaultValue ?? []];
      __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_setValueState).call(this, newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  removeSelf() {
    var _b2;
    if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isArrayItem).call(this)) {
      const newValue = (this.parent.value ?? []).filter((_, i) => i !== this.model[_key]);
      const newDefaultValue = (this.parent.defaultValue ?? []).filter((_, i) => i !== this.model[_key]);
      __classPrivateFieldGet2(_b2 = this.parent, _BinderNode_instances, "m", _BinderNode_setValueState).call(_b2, newValue, newDefaultValue);
    } else {
      throw new NotArrayItemModelError();
    }
  }
  async validate() {
    const errors = await Promise.all([
      ...__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_requestValidationOfDescendants).call(this),
      ...__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_requestValidationWithAncestors).call(this)
    ]).then((arr) => arr.flat());
    this[_setErrorsWithDescendants](errors.length ? errors : void 0);
    this[_update]();
    return errors;
  }
  [(_BinderNode_ownErrors = /* @__PURE__ */ new WeakMap(), _BinderNode_validators = /* @__PURE__ */ new WeakMap(), _BinderNode_validityStateValidator = /* @__PURE__ */ new WeakMap(), _BinderNode_visited = /* @__PURE__ */ new WeakMap(), _BinderNode_instances = /* @__PURE__ */ new WeakSet(), _a2 = _validity, _clearValidation)]() {
    if (__classPrivateFieldGet2(this, _BinderNode_visited, "f")) {
      __classPrivateFieldSet2(this, _BinderNode_visited, false, "f");
      this.dispatchEvent(CHANGED);
    }
    let needsUpdate = false;
    if (__classPrivateFieldGet2(this, _BinderNode_ownErrors, "f")) {
      __classPrivateFieldSet2(this, _BinderNode_ownErrors, void 0, "f");
      needsUpdate = true;
      this.dispatchEvent(CHANGED);
    }
    if ([...__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_getChildBinderNodes).call(this)].filter((childBinderNode) => childBinderNode[_clearValidation]()).length > 0) {
      needsUpdate = true;
    }
    return needsUpdate;
  }
  [_setErrorsWithDescendants](errors) {
    const { name } = this;
    const ownErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError) === name) : void 0;
    const relatedErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError).startsWith(name)) : void 0;
    __classPrivateFieldSet2(this, _BinderNode_ownErrors, ownErrors, "f");
    for (const childBinderNode of __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_getChildBinderNodes).call(this)) {
      childBinderNode[_setErrorsWithDescendants](relatedErrors);
    }
    this.dispatchEvent(CHANGED);
  }
  [_update](_) {
    if (this.parent) {
      this.parent[_update]();
    }
  }
  async [_updateValidation]() {
    if (this.invalid) {
      await this.validate();
    }
  }
  initializeValue(forceInitialize = false) {
    if (this.parent && (this.parent.value === void 0 || this.parent.defaultValue === void 0)) {
      this.parent.initializeValue(true);
    }
    const key = this.model[_key];
    let value = this.parent ? this.parent.value[this.model[_key]] : void 0;
    const defaultValue = this.parent ? this.parent.defaultValue[this.model[_key]] : void 0;
    if (value === void 0) {
      if (forceInitialize || !this.parent) {
        value = this.model.constructor.createEmptyValue();
        __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_setValueState).call(this, value, defaultValue === void 0 ? value : defaultValue);
      } else if (this.parent.model instanceof ObjectModel && !(key in (this.parent.value || {}))) {
        __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_setValueState).call(this, void 0, defaultValue === void 0 ? value : defaultValue);
      }
    }
  }
};
_BinderNode_getChildBinderNodes = function* _BinderNode_getChildBinderNodes2() {
  if (this.value === void 0 || this.defaultValue === void 0) {
    return;
  }
  if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isObject).call(this)) {
    for (const [, getter] of getObjectModelOwnAndParentGetters(this.model)) {
      const childModel = getter.call(this.model);
      if (childModel[_key] in this.defaultValue) {
        yield getBinderNode(childModel);
      }
    }
  } else if (__classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_isArray).call(this)) {
    for (const childBinderNode of this.model) {
      yield childBinderNode;
    }
  }
}, _BinderNode_isArray = function _BinderNode_isArray2() {
  return this.model instanceof ArrayModel;
}, _BinderNode_isArrayItem = function _BinderNode_isArrayItem2() {
  return this.model[_parent] instanceof ArrayModel;
}, _BinderNode_isObject = function _BinderNode_isObject2() {
  return this.model instanceof ObjectModel;
}, _BinderNode_requestValidationOfDescendants = function* _BinderNode_requestValidationOfDescendants2() {
  for (const node of __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_getChildBinderNodes).call(this)) {
    yield* __classPrivateFieldGet2(node, _BinderNode_instances, "m", _BinderNode_runOwnValidators).call(node);
    yield* __classPrivateFieldGet2(node, _BinderNode_instances, "m", _BinderNode_requestValidationOfDescendants2).call(node);
  }
}, _BinderNode_requestValidationWithAncestors = function* _BinderNode_requestValidationWithAncestors2() {
  var _b2;
  yield* __classPrivateFieldGet2(this, _BinderNode_instances, "m", _BinderNode_runOwnValidators).call(this);
  if (this.parent) {
    yield* __classPrivateFieldGet2(_b2 = this.parent, _BinderNode_instances, "m", _BinderNode_requestValidationWithAncestors2).call(_b2);
  }
}, _BinderNode_runOwnValidators = function* _BinderNode_runOwnValidators2() {
  var _a3;
  const hasInvalidState = this[_validity] && !this[_validity].valid;
  const hasBadInput = !!((_a3 = this[_validity]) == null ? void 0 : _a3.badInput);
  if (hasInvalidState && !hasBadInput || !hasInvalidState) {
    for (const validator of __classPrivateFieldGet2(this, _BinderNode_validators, "f")) {
      yield this.binder.requestValidation(this.model, validator);
    }
  }
  if (hasInvalidState) {
    yield this.binder.requestValidation(this.model, __classPrivateFieldGet2(this, _BinderNode_validityStateValidator, "f"));
  }
}, _BinderNode_setValueState = function _BinderNode_setValueState2(value, defaultValue) {
  const { parent } = this;
  if (parent) {
    const key = this.model[_key];
    const parentValue = updateObjectOrArrayKey(parent.model, parent.value, key, value);
    const keepPristine = value === defaultValue && parent.value === parent.defaultValue;
    if (keepPristine) {
      __classPrivateFieldGet2(parent, _BinderNode_instances, "m", _BinderNode_setValueState2).call(parent, parentValue, parentValue);
    } else if (defaultValue !== void 0) {
      const parentDefaultValue = updateObjectOrArrayKey(parent.model, parent.defaultValue, key, defaultValue);
      __classPrivateFieldGet2(parent, _BinderNode_instances, "m", _BinderNode_setValueState2).call(parent, parentValue, parentDefaultValue);
    } else {
      __classPrivateFieldGet2(parent, _BinderNode_instances, "m", _BinderNode_setValueState2).call(parent, parentValue, void 0);
    }
  } else {
    const binder = this;
    if (defaultValue !== void 0) {
      binder.defaultValue = defaultValue;
    }
    binder.value = value;
  }
};

// node_modules/@vaadin/hilla-lit-form/Field.js
import { noChange, nothing } from "lit";
import { directive, Directive, PartType } from "lit/directive.js";
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _AbstractFieldStrategy_instances;
var _AbstractFieldStrategy_element;
var _AbstractFieldStrategy_validityFallback;
var _AbstractFieldStrategy_eventHandlers;
var _AbstractFieldStrategy_getEventHandler;
var _AbstractFieldStrategy_setEventHandler;
var _AbstractFieldStrategy_detectValidityError;
var _VaadinFieldStrategy_instances;
var _VaadinFieldStrategy_invalid;
var _VaadinFieldStrategy_boundOnValidated;
var _VaadinFieldStrategy_boundOnUnparsableChange;
var _VaadinFieldStrategy_onValidated;
var _VaadinFieldStrategy_onUnparsableChange;
var props = ["required", "invalid", "errorMessage", "value", "validity", "checkValidity"];
function isFieldElement(element) {
  return props.some((prop) => prop in element);
}
var AbstractFieldStrategy = class {
  constructor(element, model) {
    _AbstractFieldStrategy_instances.add(this);
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _AbstractFieldStrategy_element.set(this, void 0);
    _AbstractFieldStrategy_validityFallback.set(this, defaultValidity);
    _AbstractFieldStrategy_eventHandlers.set(this, /* @__PURE__ */ new Map());
    __classPrivateFieldSet3(this, _AbstractFieldStrategy_element, element, "f");
    this.model = model;
  }
  get element() {
    return __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f");
  }
  set element(element) {
    __classPrivateFieldSet3(this, _AbstractFieldStrategy_element, element, "f");
  }
  get value() {
    return __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").value;
  }
  set value(value) {
    if (this.model instanceof StringModel || this.model instanceof NumberModel) {
      __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").value = value ?? "";
      return;
    }
    __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").value = value;
  }
  set errorMessage(_) {
  }
  get validity() {
    return __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").validity ?? __classPrivateFieldGet3(this, _AbstractFieldStrategy_validityFallback, "f");
  }
  get onChange() {
    return __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").get("change");
  }
  set onChange(onChange) {
    __classPrivateFieldGet3(this, _AbstractFieldStrategy_instances, "m", _AbstractFieldStrategy_setEventHandler).call(this, "change", onChange);
  }
  get onInput() {
    return __classPrivateFieldGet3(this, _AbstractFieldStrategy_instances, "m", _AbstractFieldStrategy_getEventHandler).call(this, "input");
  }
  set onInput(onInput) {
    __classPrivateFieldGet3(this, _AbstractFieldStrategy_instances, "m", _AbstractFieldStrategy_setEventHandler).call(this, "input", onInput);
  }
  checkValidity() {
    if (!__classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").checkValidity) {
      return true;
    }
    const valid = __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").checkValidity();
    __classPrivateFieldSet3(this, _AbstractFieldStrategy_validityFallback, {
      ...defaultValidity,
      valid,
      ...valid ? {} : __classPrivateFieldGet3(this, _AbstractFieldStrategy_instances, "m", _AbstractFieldStrategy_detectValidityError).call(this)
    }, "f");
    return valid;
  }
  setAttribute(key, val) {
    if (val) {
      __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").setAttribute(key, "");
    } else {
      __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").removeAttribute(key);
    }
  }
  removeEventListeners() {
    for (const [type, handler] of __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f")) {
      this.element.removeEventListener(type, handler);
      __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").delete(type);
    }
  }
};
_AbstractFieldStrategy_element = /* @__PURE__ */ new WeakMap(), _AbstractFieldStrategy_validityFallback = /* @__PURE__ */ new WeakMap(), _AbstractFieldStrategy_eventHandlers = /* @__PURE__ */ new WeakMap(), _AbstractFieldStrategy_instances = /* @__PURE__ */ new WeakSet(), _AbstractFieldStrategy_getEventHandler = function _AbstractFieldStrategy_getEventHandler2(type) {
  return __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").get(type);
}, _AbstractFieldStrategy_setEventHandler = function _AbstractFieldStrategy_setEventHandler2(type, handler) {
  if (__classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").has(type)) {
    this.element.removeEventListener(type, __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").get(type));
  }
  if (handler) {
    this.element.addEventListener(type, handler);
    __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").set(type, handler);
  } else {
    __classPrivateFieldGet3(this, _AbstractFieldStrategy_eventHandlers, "f").delete(type);
  }
}, _AbstractFieldStrategy_detectValidityError = function _AbstractFieldStrategy_detectValidityError2() {
  if (!("inputElement" in __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f"))) {
    return { customError: true };
  }
  const inputElement = __classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").inputElement;
  if (__classPrivateFieldGet3(this, _AbstractFieldStrategy_element, "f").value === "") {
    if (inputElement.value === "") {
      return { valueMissing: true };
    }
    return { badInput: true };
  }
  return { customError: true };
};
var VaadinFieldStrategy = class extends AbstractFieldStrategy {
  constructor(element, model) {
    super(element, model);
    _VaadinFieldStrategy_instances.add(this);
    _VaadinFieldStrategy_invalid.set(this, false);
    _VaadinFieldStrategy_boundOnValidated.set(this, __classPrivateFieldGet3(this, _VaadinFieldStrategy_instances, "m", _VaadinFieldStrategy_onValidated).bind(this));
    _VaadinFieldStrategy_boundOnUnparsableChange.set(this, __classPrivateFieldGet3(this, _VaadinFieldStrategy_instances, "m", _VaadinFieldStrategy_onUnparsableChange).bind(this));
    element.addEventListener("validated", __classPrivateFieldGet3(this, _VaadinFieldStrategy_boundOnValidated, "f"));
    element.addEventListener("unparsable-change", __classPrivateFieldGet3(this, _VaadinFieldStrategy_boundOnUnparsableChange, "f"));
  }
  set required(value) {
    this.element.required = value;
  }
  set invalid(value) {
    __classPrivateFieldSet3(this, _VaadinFieldStrategy_invalid, value, "f");
    this.element.invalid = value;
  }
  set errorMessage(value) {
    this.element.errorMessage = value;
  }
  removeEventListeners() {
    this.element.removeEventListener("validated", __classPrivateFieldGet3(this, _VaadinFieldStrategy_boundOnValidated, "f"));
    this.element.removeEventListener("unparsable-change", __classPrivateFieldGet3(this, _VaadinFieldStrategy_boundOnUnparsableChange, "f"));
  }
  checkValidity() {
    const isElementInvalid = this.element.invalid;
    this.element.invalid = false;
    const valid = super.checkValidity();
    this.element.invalid = isElementInvalid;
    return valid;
  }
};
_VaadinFieldStrategy_invalid = /* @__PURE__ */ new WeakMap(), _VaadinFieldStrategy_boundOnValidated = /* @__PURE__ */ new WeakMap(), _VaadinFieldStrategy_boundOnUnparsableChange = /* @__PURE__ */ new WeakMap(), _VaadinFieldStrategy_instances = /* @__PURE__ */ new WeakSet(), _VaadinFieldStrategy_onValidated = function _VaadinFieldStrategy_onValidated2(e2) {
  var _a3;
  if (!(e2 instanceof CustomEvent) || typeof e2.detail !== "object") {
    return;
  }
  const invalid = !(e2.detail ?? {}).valid;
  if (__classPrivateFieldGet3(this, _VaadinFieldStrategy_invalid, "f") !== invalid) {
    this.element.invalid = __classPrivateFieldGet3(this, _VaadinFieldStrategy_invalid, "f");
  }
  (_a3 = this.onInput) == null ? void 0 : _a3.call(this.element, e2);
}, _VaadinFieldStrategy_onUnparsableChange = function _VaadinFieldStrategy_onUnparsableChange2(e2) {
  var _a3;
  (_a3 = this.onChange) == null ? void 0 : _a3.call(this.element, e2);
};
var GenericFieldStrategy = class extends AbstractFieldStrategy {
  set required(value) {
    this.setAttribute("required", value);
  }
  set invalid(value) {
    this.setAttribute("invalid", value);
  }
};
var CheckedFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    if (this.model instanceof BooleanModel) {
      return this.element.checked;
    }
    return this.element.checked ? this.element.value : void 0;
  }
  set value(val) {
    this.element.checked = /^(true|on)$/iu.test(String(val));
  }
};
var CheckedGroupFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    super.value = val ?? [];
  }
};
var ComboBoxFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {
      const { selectedItem } = this.element;
      return selectedItem ?? void 0;
    }
    return super.value;
  }
  set value(val) {
    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {
      this.element.selectedItem = val ?? null;
    } else {
      super.value = val;
    }
  }
};
var VaadinStringFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    super.value = val ?? "";
  }
};
function isEmptyObject(val) {
  return val && typeof val === "object" && !Array.isArray(val) && Object.keys(val).length === 0;
}
var VaadinDateTimeFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    const timestamp = Date.parse(val);
    if (!val || isEmptyObject(val) || Number.isNaN(timestamp)) {
      super.value = "";
      return;
    }
    const date = new Date(timestamp);
    const tzOffsetMs = 60 * 1e3 * date.getTimezoneOffset();
    super.value = new Date(timestamp - tzOffsetMs).toISOString().slice(0, 19);
  }
};
var MultiSelectComboBoxFieldStrategy = class extends VaadinFieldStrategy {
  get value() {
    return this.element.selectedItems;
  }
  set value(val) {
    this.element.selectedItems = val;
  }
};
var SelectedFieldStrategy = class extends GenericFieldStrategy {
  get value() {
    return this.element.selected;
  }
  set value(val) {
    this.element.selected = val;
  }
};
function getDefaultFieldStrategy(elm, model) {
  switch (elm.localName) {
    case "vaadin-checkbox":
    case "vaadin-radio-button":
      return new CheckedFieldStrategy(elm, model);
    case "vaadin-checkbox-group":
      return new CheckedGroupFieldStrategy(elm, model);
    case "vaadin-combo-box":
      return new ComboBoxFieldStrategy(elm, model);
    case "vaadin-list-box":
      return new SelectedFieldStrategy(elm, model);
    case "vaadin-multi-select-combo-box":
      return new MultiSelectComboBoxFieldStrategy(elm, model);
    case "vaadin-rich-text-editor":
      return new GenericFieldStrategy(elm, model);
    case "vaadin-time-picker":
      return new VaadinStringFieldStrategy(elm, model);
    case "vaadin-date-time-picker":
      return new VaadinDateTimeFieldStrategy(elm, model);
    default:
      if (elm.localName === "input" && /^(checkbox|radio)$/u.test(elm.type)) {
        return new CheckedFieldStrategy(elm, model);
      }
      if (elm.constructor.version) {
        return new VaadinFieldStrategy(elm, model);
      }
      return new GenericFieldStrategy(elm, model);
  }
}
function convertFieldValue(model, fieldValue) {
  return typeof fieldValue === "string" && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
var field = directive(class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    Object.defineProperty(this, "fieldState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {
      throw new Error('Use as "<element {field(...)}" or <element ...={field(...)}"');
    }
  }
  render(_model, _effect) {
    return nothing;
  }
  update(part, [model, effect]) {
    const element = part.element;
    const binderNode = getBinderNode(model);
    if (!this.fieldState) {
      const fieldState2 = {
        errorMessage: "",
        name: "",
        value: "",
        required: false,
        invalid: false,
        model,
        validity: defaultValidity,
        element,
        strategy: binderNode.binder.getFieldStrategy(element, model)
      };
      this.fieldState = fieldState2;
      const inputHandler = () => {
        fieldState2.strategy.checkValidity();
        if (!fieldState2.strategy.validity.badInput) {
          fieldState2.value = fieldState2.strategy.value;
        }
        fieldState2.validity = fieldState2.strategy.validity;
        binderNode[_validity] = fieldState2.validity;
        binderNode.value = convertFieldValue(model, fieldState2.value);
        if (effect !== void 0) {
          effect.call(element, element);
        }
      };
      fieldState2.strategy.onInput = inputHandler;
      fieldState2.strategy.onChange = () => {
        inputHandler();
        void binderNode.validate();
      };
      const blurHandler = () => {
        inputHandler();
        void binderNode.validate();
        binderNode.visited = true;
      };
      element.addEventListener("blur", blurHandler);
    }
    const { fieldState } = this;
    if (fieldState.element !== element || fieldState.model !== model) {
      const { onInput } = fieldState.strategy;
      fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);
      fieldState.strategy.onInput = onInput;
    }
    const { name } = binderNode;
    if (name !== fieldState.name) {
      fieldState.name = name;
      element.setAttribute("name", name);
    }
    const { value } = binderNode;
    const valueFromField = convertFieldValue(model, fieldState.value);
    if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {
      const nonNanValue = Number.isNaN(value) ? "" : value;
      fieldState.value = nonNanValue;
      fieldState.strategy.value = nonNanValue;
    }
    const { required } = binderNode;
    if (required !== fieldState.required) {
      fieldState.required = required;
      fieldState.strategy.required = required;
    }
    const firstError = binderNode.ownErrors[0];
    const errorMessage = (firstError == null ? void 0 : firstError.message) || "";
    if (errorMessage !== fieldState.errorMessage) {
      fieldState.errorMessage = errorMessage;
      fieldState.strategy.errorMessage = errorMessage;
    }
    const { invalid } = binderNode;
    if (invalid !== fieldState.invalid) {
      fieldState.invalid = invalid;
      fieldState.strategy.invalid = invalid;
    }
    return noChange;
  }
});

// node_modules/@vaadin/hilla-lit-form/Validation.js
var ValidationError = class extends Error {
  constructor(errors) {
    super([
      "There are validation errors in the form.",
      ...errors.map((e2) => {
        const property = e2.property instanceof AbstractModel ? String(getBinderNode(e2.property).value) : e2.property;
        return `${property} - ${e2.validator.constructor.name}${e2.message ? `: ${e2.message}` : ""}`;
      })
    ].join("\n - "));
    Object.defineProperty(this, "errors", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.errors = errors;
    this.name = this.constructor.name;
  }
};
var ServerValidator = class {
  constructor(message) {
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ServerValidator"
    });
    Object.defineProperty(this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "validate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => false
    });
    this.message = message;
  }
};
function setPropertyAbsolutePath(binderNodeName, result) {
  if (typeof result.property === "string" && binderNodeName.length > 0) {
    result.property = `${binderNodeName}.${result.property}`;
  }
  return result;
}
async function runValidator(model, validator, interpolateMessageCallback) {
  const binderNode = getBinderNode(model);
  const value = binderNode.value;
  const interpolateMessage = (message) => {
    if (!interpolateMessageCallback) {
      return message;
    }
    return interpolateMessageCallback(message, validator, binderNode);
  };
  if (!binderNode.required && !new Required().validate(value) && !(validator instanceof IsNumber) && !(validator instanceof ValidityStateValidator)) {
    return [];
  }
  try {
    const result = await validator.validate(value, binderNode.binder);
    if (result === false) {
      return [
        {
          message: interpolateMessage(validator.message),
          property: binderNode.name,
          validator,
          value
        }
      ];
    }
    if (result === true || Array.isArray(result) && result.length === 0) {
      return [];
    }
    if (Array.isArray(result)) {
      return result.map((result2) => ({
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result2),
        validator,
        value
      }));
    }
    return [
      {
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result),
        validator,
        value
      }
    ];
  } catch (error) {
    console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);
    return [{ message: "Validator threw an error", property: binderNode.name, validator, value }];
  }
}

// node_modules/@vaadin/hilla-lit-form/BinderRoot.js
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _BinderRoot_defaultValue;
var _BinderRoot_value;
var _BinderRoot_emptyValue;
var _BinderRoot_submitting;
var _BinderRoot_validating;
var _BinderRoot_validationRequest;
var _BinderRoot_config;
var _BinderRoot_validations;
var _BinderRoot_context;
var BinderRoot = class extends BinderNode {
  constructor(Model, config) {
    super(createDetachedModel(Model));
    _BinderRoot_defaultValue.set(this, void 0);
    _BinderRoot_value.set(this, void 0);
    _BinderRoot_emptyValue.set(this, void 0);
    _BinderRoot_submitting.set(this, false);
    _BinderRoot_validating.set(this, false);
    _BinderRoot_validationRequest.set(this, void 0);
    _BinderRoot_config.set(this, void 0);
    _BinderRoot_validations.set(this, /* @__PURE__ */ new Map());
    _BinderRoot_context.set(this, this);
    this.model[_parent] = this;
    __classPrivateFieldSet4(this, _BinderRoot_context, (config == null ? void 0 : config.context) ?? this, "f");
    __classPrivateFieldSet4(this, _BinderRoot_config, config, "f");
    this.initializeValue(true);
    __classPrivateFieldSet4(this, _BinderRoot_emptyValue, this.value, "f");
  }
  get defaultValue() {
    return __classPrivateFieldGet4(this, _BinderRoot_defaultValue, "f");
  }
  set defaultValue(newValue) {
    __classPrivateFieldSet4(this, _BinderRoot_defaultValue, newValue, "f");
    this.dispatchEvent(CHANGED);
  }
  get binder() {
    return this;
  }
  get value() {
    return __classPrivateFieldGet4(this, _BinderRoot_value, "f");
  }
  set value(newValue) {
    if (newValue === __classPrivateFieldGet4(this, _BinderRoot_value, "f")) {
      return;
    }
    const oldValue = __classPrivateFieldGet4(this, _BinderRoot_value, "f");
    __classPrivateFieldSet4(this, _BinderRoot_value, newValue, "f");
    this[_update](oldValue);
  }
  get submitting() {
    return __classPrivateFieldGet4(this, _BinderRoot_submitting, "f");
  }
  get validating() {
    return __classPrivateFieldGet4(this, _BinderRoot_validating, "f");
  }
  read(value) {
    if (value === void 0 || value === null) {
      this.clear();
      return;
    }
    this.defaultValue = value;
    if (this.value && this[_clearValidation]() && this.value === value) {
      this[_update](this.value);
    }
    this.value = this.defaultValue;
  }
  reset() {
    this.read(__classPrivateFieldGet4(this, _BinderRoot_defaultValue, "f"));
  }
  clear() {
    this.read(__classPrivateFieldGet4(this, _BinderRoot_emptyValue, "f"));
  }
  async submit() {
    var _a3;
    const onSubmit = (_a3 = __classPrivateFieldGet4(this, _BinderRoot_config, "f")) == null ? void 0 : _a3.onSubmit;
    if (onSubmit) {
      return this.submitTo(onSubmit);
    }
    return void 0;
  }
  async submitTo(endpointMethod) {
    const errors = await this.validate();
    if (errors.length) {
      throw new ValidationError(errors);
    }
    __classPrivateFieldSet4(this, _BinderRoot_submitting, true, "f");
    this[_update](this.value);
    this.dispatchEvent(CHANGED);
    try {
      return await endpointMethod.call(__classPrivateFieldGet4(this, _BinderRoot_context, "f"), this.value);
    } catch (error) {
      if (error instanceof EndpointValidationError && error.validationErrorData.length) {
        const valueErrors = [];
        error.validationErrorData.forEach((data) => {
          const res = /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(data.message);
          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? "", void 0, data.message];
          valueErrors.push({
            message,
            property: property.replace(/\[(\d+)\]/gu, ".$1"),
            validator: new ServerValidator(message),
            value,
            validatorMessage: data.validatorMessage
          });
        });
        this[_setErrorsWithDescendants](valueErrors);
        throw new ValidationError(valueErrors);
      }
      throw error;
    } finally {
      __classPrivateFieldSet4(this, _BinderRoot_submitting, false, "f");
      this.defaultValue = this.value;
      this[_update](this.value);
    }
  }
  async requestValidation(model, validator) {
    let modelValidations;
    if (__classPrivateFieldGet4(this, _BinderRoot_validations, "f").has(model)) {
      modelValidations = __classPrivateFieldGet4(this, _BinderRoot_validations, "f").get(model);
    } else {
      modelValidations = /* @__PURE__ */ new Map();
      __classPrivateFieldGet4(this, _BinderRoot_validations, "f").set(model, modelValidations);
    }
    await this.performValidation();
    if (modelValidations.has(validator)) {
      return modelValidations.get(validator);
    }
    const promise = runValidator(model, validator, this.constructor.interpolateMessageCallback);
    modelValidations.set(validator, promise);
    const valueErrors = await promise;
    modelValidations.delete(validator);
    if (modelValidations.size === 0) {
      __classPrivateFieldGet4(this, _BinderRoot_validations, "f").delete(model);
    }
    if (__classPrivateFieldGet4(this, _BinderRoot_validations, "f").size === 0) {
      this.completeValidation();
    }
    return valueErrors;
  }
  getFieldStrategy(elm, model) {
    return getDefaultFieldStrategy(elm, model);
  }
  performValidation() {
    if (!__classPrivateFieldGet4(this, _BinderRoot_validationRequest, "f")) {
      __classPrivateFieldSet4(this, _BinderRoot_validating, true, "f");
      this.dispatchEvent(CHANGED);
      __classPrivateFieldSet4(this, _BinderRoot_validationRequest, Promise.resolve().then(() => {
        __classPrivateFieldSet4(this, _BinderRoot_validationRequest, void 0, "f");
      }), "f");
    }
    return __classPrivateFieldGet4(this, _BinderRoot_validationRequest, "f");
  }
  completeValidation() {
    __classPrivateFieldSet4(this, _BinderRoot_validating, false, "f");
    this.dispatchEvent(CHANGED);
  }
  [(_BinderRoot_defaultValue = /* @__PURE__ */ new WeakMap(), _BinderRoot_value = /* @__PURE__ */ new WeakMap(), _BinderRoot_emptyValue = /* @__PURE__ */ new WeakMap(), _BinderRoot_submitting = /* @__PURE__ */ new WeakMap(), _BinderRoot_validating = /* @__PURE__ */ new WeakMap(), _BinderRoot_validationRequest = /* @__PURE__ */ new WeakMap(), _BinderRoot_config = /* @__PURE__ */ new WeakMap(), _BinderRoot_validations = /* @__PURE__ */ new WeakMap(), _BinderRoot_context = /* @__PURE__ */ new WeakMap(), _update)](oldValue) {
    var _a3, _b2;
    (_b2 = (_a3 = __classPrivateFieldGet4(this, _BinderRoot_config, "f")) == null ? void 0 : _a3.onChange) == null ? void 0 : _b2.call(__classPrivateFieldGet4(this, _BinderRoot_context, "f"), oldValue);
    this.dispatchEvent(CHANGED);
  }
};

// node_modules/@vaadin/hilla-lit-form/index.js
((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `@vaadin/hilla-lit-form/${feature}` : "@vaadin/hilla-lit-form",
    version: "24.7.2"
  });
})();

// node_modules/@vaadin/hilla-react-crud/header-filter.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/types/com/vaadin/hilla/crud/filter/PropertyStringFilter/Matcher.js
var Matcher;
(function(Matcher2) {
  Matcher2["EQUALS"] = "EQUALS";
  Matcher2["CONTAINS"] = "CONTAINS";
  Matcher2["LESS_THAN"] = "LESS_THAN";
  Matcher2["GREATER_THAN"] = "GREATER_THAN";
})(Matcher || (Matcher = {}));
var Matcher_default = Matcher;

// node_modules/@vaadin/hilla-react-crud/header-filter.js
function useFilterState(initialMatcher) {
  const context = (0, import_react5.useContext)(ColumnContext);
  const [matcher, setMatcher] = (0, import_react5.useState)(initialMatcher);
  const [filterValue, setFilterValue] = (0, import_react5.useState)("");
  function updateFilter(newMatcher, newFilterValue) {
    setFilterValue(newFilterValue);
    setMatcher(newMatcher);
    const filter = {
      propertyId: context.propertyInfo.name,
      filterValue: newFilterValue,
      matcher: newMatcher,
      "@type": "propertyString"
    };
    context.setColumnFilter(filter, context.filterKey);
  }
  return { matcher, filterValue, updateFilter };
}
function useSelectInitWorkaround(selectRef) {
  (0, import_react5.useEffect)(() => {
    setTimeout(() => {
      if (selectRef.current) {
        selectRef.current.requestContentUpdate();
      }
    }, 1);
  }, []);
}
function ComparationSelection({ onMatcherChanged, value, isDateTimeType }) {
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  return (0, import_jsx_runtime3.jsx)(O, { theme: "small", className: "auto-grid-comparation-selection", ref: select, value, onValueChanged: ({ detail }) => {
    onMatcherChanged(detail.value);
  }, renderer: () => (0, import_jsx_runtime3.jsxs)(p, { children: [(0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.GREATER_THAN, label: ">", children: isDateTimeType ? "> After" : "> Greater than" }), (0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.LESS_THAN, label: "<", children: isDateTimeType ? "< Before" : "< Less than" }), (0, import_jsx_runtime3.jsx)(n, { value: Matcher_default.EQUALS, label: "=", children: "= Equals" })] }) });
}
function StringHeaderFilter() {
  const context = (0, import_react5.useContext)(ColumnContext);
  const { filterPlaceholder, filterDebounceTime, filterMinLength } = context.customColumnOptions ?? {};
  const { updateFilter } = useFilterState(Matcher_default.CONTAINS);
  const [inputValue, setInputValue] = (0, import_react5.useState)("");
  (0, import_react5.useEffect)(() => {
    if (filterMinLength && inputValue && inputValue.length < filterMinLength) {
      updateFilter(Matcher_default.CONTAINS, "");
      return () => {
      };
    }
    const delayInputTimeoutId = setTimeout(() => {
      updateFilter(Matcher_default.CONTAINS, inputValue);
    }, filterDebounceTime ?? 200);
    return () => clearTimeout(delayInputTimeoutId);
  }, [inputValue]);
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-string-filter", children: (0, import_jsx_runtime3.jsx)(p2, { theme: "small", placeholder: filterPlaceholder ?? "Filter...", onInput: (e2) => {
    const fieldValue = e2.target.value;
    setInputValue(fieldValue);
  } }) });
}
function NumberHeaderFilter() {
  const context = (0, import_react5.useContext)(ColumnContext);
  const { filterPlaceholder, filterDebounceTime } = context.customColumnOptions ?? {};
  const [inputValue, setInputValue] = (0, import_react5.useState)("");
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  (0, import_react5.useEffect)(() => {
    const delayInputTimeoutId = setTimeout(() => {
      updateFilter(matcher, inputValue);
    }, filterDebounceTime ?? 200);
    return () => clearTimeout(delayInputTimeoutId);
  }, [inputValue]);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-number-filter", children: [(0, import_jsx_runtime3.jsx)(ComparationSelection, { value: matcher, onMatcherChanged: (m4) => updateFilter(m4, filterValue) }), (0, import_jsx_runtime3.jsx)(o, { theme: "small", placeholder: filterPlaceholder ?? "Filter...", onInput: (e2) => {
    const fieldValue = e2.target.value;
    setInputValue(fieldValue);
  } })] });
}
function EnumHeaderFilter() {
  const { filterValue, updateFilter } = useFilterState(Matcher_default.EQUALS);
  const context = (0, import_react5.useContext)(ColumnContext);
  const model = context.propertyInfo.model;
  const options = [
    {
      value: "",
      label: ""
    },
    ...Object.keys(model[_enum]).map((value) => ({
      label: convertToTitleCase(value),
      value
    }))
  ];
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-enum-filter", children: (0, import_jsx_runtime3.jsx)(O, { theme: "small", items: options, value: filterValue, onValueChanged: (e2) => {
    const newFilterValue = e2.detail.value;
    updateFilter(Matcher_default.EQUALS, newFilterValue);
  } }) });
}
function BooleanHeaderFilter() {
  const { filterValue, updateFilter } = useFilterState(Matcher_default.EQUALS);
  const select = (0, import_react5.useRef)(null);
  useSelectInitWorkaround(select);
  return (0, import_jsx_runtime3.jsx)("div", { className: "auto-grid-boolean-filter", children: (0, import_jsx_runtime3.jsx)(O, { theme: "small", ref: select, onValueChanged: (e2) => {
    const newFilterValue = e2.detail.value;
    updateFilter(Matcher_default.EQUALS, newFilterValue);
  }, renderer: () => (0, import_jsx_runtime3.jsxs)(p, { children: [(0, import_jsx_runtime3.jsx)(n, { value: "", label: "" }), (0, import_jsx_runtime3.jsx)(n, { value: "True", label: "Yes", children: "Yes" }), (0, import_jsx_runtime3.jsx)(n, { value: "False", label: "No", children: "No" })] }), value: filterValue }) });
}
function DateHeaderFilter() {
  var _a3;
  const context = (0, import_react5.useContext)(ColumnContext);
  const i18n = useDatePickerI18n();
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const [invalid, setInvalid] = (0, import_react5.useState)(false);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-date-filter", children: [(0, import_jsx_runtime3.jsx)(ComparationSelection, { value: matcher, onMatcherChanged: (m4) => updateFilter(m4, filterValue), isDateTimeType: true }), (0, import_jsx_runtime3.jsx)(r, { theme: "small", value: filterValue, placeholder: ((_a3 = context.customColumnOptions) == null ? void 0 : _a3.filterPlaceholder) ?? "Filter...", i18n, onInvalidChanged: ({ detail: { value } }) => {
    setInvalid(value);
  }, onValueChanged: ({ detail: { value } }) => {
    if (!(invalid || value === filterValue)) {
      updateFilter(matcher, value);
    }
  } })] });
}
function TimeHeaderFilter() {
  var _a3;
  const context = (0, import_react5.useContext)(ColumnContext);
  const { matcher, filterValue, updateFilter } = useFilterState(Matcher_default.GREATER_THAN);
  const [invalid, setInvalid] = (0, import_react5.useState)(false);
  return (0, import_jsx_runtime3.jsxs)("div", { className: "auto-grid-time-filter", children: [(0, import_jsx_runtime3.jsx)(ComparationSelection, { value: matcher, onMatcherChanged: (m4) => updateFilter(m4, filterValue), isDateTimeType: true }), (0, import_jsx_runtime3.jsx)(k2, { theme: "small", value: filterValue, placeholder: ((_a3 = context.customColumnOptions) == null ? void 0 : _a3.filterPlaceholder) ?? "Filter...", onInvalidChanged: ({ detail: { value } }) => {
    setInvalid(value);
  }, onValueChanged: ({ detail: { value } }) => {
    if (!(invalid || value === filterValue)) {
      updateFilter(matcher, value);
    }
  } })] });
}
function NoHeaderFilter() {
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, {});
}
function HeaderFilterWrapper({ original }) {
  const context = (0, import_react5.useContext)(ColumnContext);
  const customContext = (0, import_react5.useContext)(CustomColumnContext);
  const { setColumnFilter, headerFilterRenderer: HeaderFilterRenderer, filterKey } = context ?? customContext;
  function setFilter(filter) {
    setColumnFilter(filter, filterKey);
  }
  return (0, import_jsx_runtime3.jsx)(HeaderFilterRenderer, { original, setFilter });
}

// node_modules/@vaadin/hilla-react-crud/autogrid-columns.js
function getTypeColumnOptions(propertyInfo, customColumnOptions) {
  switch (propertyInfo.type) {
    case "integer":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridIntegerRenderer,
        headerFilterRenderer: NumberHeaderFilter
      };
    case "decimal":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDecimalRenderer,
        headerFilterRenderer: NumberHeaderFilter
      };
    case "boolean":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridBooleanRenderer,
        headerFilterRenderer: BooleanHeaderFilter
      };
    case "date":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDateRenderer,
        headerFilterRenderer: DateHeaderFilter
      };
    case "time":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridTimeRenderer,
        headerFilterRenderer: TimeHeaderFilter
      };
    case "datetime":
      return {
        autoWidth: true,
        textAlign: "end",
        flexGrow: 0,
        renderer: AutoGridDateTimeRenderer,
        headerFilterRenderer: DateHeaderFilter
      };
    case "enum":
      return {
        autoWidth: true,
        renderer: AutoGridEnumRenderer,
        headerFilterRenderer: EnumHeaderFilter
      };
    case "string":
      return {
        autoWidth: true,
        headerFilterRenderer: StringHeaderFilter
      };
    case "object":
      return {
        autoWidth: true,
        renderer: (customColumnOptions == null ? void 0 : customColumnOptions.path) !== void 0 && customColumnOptions.renderer == null ? null : AutoGridJsonRenderer,
        headerFilterRenderer: NoHeaderFilter
      };
    default:
      return {
        autoWidth: true,
        headerFilterRenderer: NoHeaderFilter
      };
  }
}
function getColumnOptions(propertyInfo, customColumnOptions) {
  const typeColumnOptions = getTypeColumnOptions(propertyInfo, customColumnOptions);
  const headerFilterRenderer = (customColumnOptions == null ? void 0 : customColumnOptions.filterable) === false ? NoHeaderFilter : typeColumnOptions.headerFilterRenderer ?? NoHeaderFilter;
  return customColumnOptions ? { ...typeColumnOptions, headerFilterRenderer, ...customColumnOptions } : typeColumnOptions;
}

// node_modules/@vaadin/hilla-react-crud/autogrid.obj.js
var css = new CSSStyleSheet();
css.replaceSync(`.auto-grid-comparation-selection{--vaadin-field-default-width:2em}.auto-grid-comparation-selection>vaadin-select-value-button{--_lumo-text-field-overflow-mask-image:none!important;color:var(--lumo-secondary-text-color)}.auto-grid-comparation-selection::part(toggle-button){display:none}.auto-grid-string-filter{display:flex}.auto-grid-string-filter vaadin-text-field{flex:1 1 0;width:100px}.auto-grid-boolean-filter{display:flex}.auto-grid-boolean-filter vaadin-select{flex:1 1 0;width:80px}.auto-grid-boolean-filter vaadin-select-item{font-size:14px}.auto-grid-number-filter{display:flex}.auto-grid-number-filter vaadin-number-field{flex:1 1 0;width:100px}.auto-grid-number-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-number-filter vaadin-number-field::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}.auto-grid-enum-filter{display:flex}.auto-grid-enum-filter vaadin-select{flex:1 1 0;width:120px}.auto-grid-enum-filter vaadin-select-item{font-size:14px}.auto-grid-date-filter{display:flex}.auto-grid-date-filter vaadin-date-picker{flex:1 1 0;width:120px}.auto-grid-date-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-date-filter vaadin-date-picker::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}.auto-grid-time-filter{display:flex}.auto-grid-time-filter vaadin-time-picker{flex:1 1 0;width:100px}.auto-grid-time-filter vaadin-select::part(input-field){border-bottom-right-radius:0;border-top-right-radius:0}.auto-grid-time-filter vaadin-time-picker::part(input-field){border-bottom-left-radius:0;border-top-left-radius:0}`);
var autogrid_obj_default = css;

// node_modules/@vaadin/hilla-react-crud/data-provider.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/types/org/springframework/data/domain/Sort/Direction.js
var Direction;
(function(Direction2) {
  Direction2["ASC"] = "ASC";
  Direction2["DESC"] = "DESC";
})(Direction || (Direction = {}));
var Direction_default = Direction;

// node_modules/@vaadin/hilla-react-crud/types/org/springframework/data/domain/Sort/NullHandling.js
var NullHandling;
(function(NullHandling2) {
  NullHandling2["NATIVE"] = "NATIVE";
  NullHandling2["NULLS_FIRST"] = "NULLS_FIRST";
  NullHandling2["NULLS_LAST"] = "NULLS_LAST";
})(NullHandling || (NullHandling = {}));
var NullHandling_default = NullHandling;

// node_modules/@vaadin/hilla-react-crud/data-provider.js
function createSort(params) {
  return {
    orders: params.sortOrders.filter((order) => order.direction != null).map((order) => ({
      property: order.path,
      direction: order.direction === "asc" ? Direction_default.ASC : Direction_default.DESC,
      ignoreCase: false,
      nullHandling: NullHandling_default.NATIVE
    }))
  };
}
function isCountService(service) {
  return !!service.count;
}
var DataProvider = class {
  constructor(service, options = {}) {
    __publicField(this, "service");
    __publicField(this, "loadTotalCount");
    __publicField(this, "afterLoadCallback");
    __publicField(this, "filter");
    __publicField(this, "totalCount");
    __publicField(this, "filteredCount");
    this.service = service;
    this.filter = options.initialFilter;
    this.loadTotalCount = options.loadTotalCount;
    this.afterLoadCallback = options.afterLoad;
    this.load = this.load.bind(this);
  }
  reset() {
    this.totalCount = void 0;
    this.filteredCount = void 0;
  }
  setFilter(filter) {
    this.reset();
    this.filter = filter;
  }
  async load(params, callback) {
    const page = await this.fetchPage(params);
    this.filteredCount = await this.fetchFilteredCount(page);
    if (this.loadTotalCount) {
      this.totalCount = await this.fetchTotalCount(page);
    }
    callback(page.items, this.filteredCount);
    if (this.afterLoadCallback) {
      this.afterLoadCallback({
        totalCount: this.totalCount,
        filteredCount: this.filteredCount
      });
    }
  }
  async fetchPage(params) {
    const sort = createSort(params);
    const pageNumber = params.page;
    const { pageSize } = params;
    const pageRequest = {
      pageNumber,
      pageSize,
      sort
    };
    const items = await this.service.list(pageRequest, this.filter);
    return { items, pageRequest };
  }
};
var AbstractComboBoxDataProvider = class {
  constructor(list, sort) {
    __publicField(this, "list");
    __publicField(this, "loadTotalCount");
    __publicField(this, "sort");
    __publicField(this, "totalCount");
    __publicField(this, "filteredCount");
    this.list = list;
    this.sort = sort;
  }
  reset() {
    this.totalCount = void 0;
    this.filteredCount = void 0;
  }
  load(params, callback) {
    this.fetchPage(params).then(async (page) => {
      this.filteredCount = await this.fetchFilteredCount(page);
      if (this.loadTotalCount) {
        this.totalCount = await this.fetchTotalCount(page);
      }
      callback(page.items, this.filteredCount);
    }).catch((error) => {
      throw error;
    });
  }
  async fetchPage(params) {
    const pageNumber = params.page;
    const { pageSize } = params;
    const pageRequest = {
      pageNumber,
      pageSize,
      sort: this.sort ?? { orders: [] }
    };
    const items = await this.list(pageRequest, params.filter);
    return { items, pageRequest };
  }
};
function determineInfiniteScrollingSize(page, lastKnownSize) {
  const { items, pageRequest } = page;
  const { pageNumber, pageSize } = pageRequest;
  let infiniteScrollingSize;
  if (items.length === pageSize) {
    infiniteScrollingSize = (pageNumber + 1) * pageSize + 1;
    if (lastKnownSize !== void 0 && infiniteScrollingSize < lastKnownSize) {
      infiniteScrollingSize = lastKnownSize;
    }
  } else {
    infiniteScrollingSize = pageNumber * pageSize + items.length;
  }
  return infiniteScrollingSize;
}
var InfiniteDataProvider = class extends DataProvider {
  fetchTotalCount() {
    return void 0;
  }
  fetchFilteredCount(page) {
    return determineInfiniteScrollingSize(page, this.filteredCount);
  }
};
var InfiniteComboBoxDataProvider = class extends AbstractComboBoxDataProvider {
  fetchTotalCount() {
    return void 0;
  }
  fetchFilteredCount(page) {
    return determineInfiniteScrollingSize(page, this.filteredCount);
  }
};
var FixedSizeDataProvider = class extends DataProvider {
  constructor(service, options = {}) {
    if (!isCountService(service)) {
      throw new Error("The provided service does not implement the CountService interface.");
    }
    super(service, options);
  }
  async fetchTotalCount() {
    if (this.totalCount !== void 0) {
      return this.totalCount;
    }
    return this.service.count(void 0);
  }
  async fetchFilteredCount() {
    if (this.filteredCount !== void 0) {
      return this.filteredCount;
    }
    return this.service.count(this.filter);
  }
};
function createDataProvider(service, options = {}) {
  if (isCountService(service)) {
    return new FixedSizeDataProvider(service, options);
  }
  return new InfiniteDataProvider(service, options);
}
function useDataProvider(service, filter) {
  const [refreshCounter, setRefreshCounter] = (0, import_react6.useState)(0);
  const dataProvider = (0, import_react6.useMemo)(() => createDataProvider(service, { initialFilter: filter }), [service]);
  dataProvider.setFilter(filter);
  const dataProviderFn = (0, import_react6.useMemo)(() => dataProvider.load.bind(dataProvider), [dataProvider, filter, refreshCounter]);
  return {
    dataProvider: dataProviderFn,
    refresh: () => {
      dataProvider.reset();
      setRefreshCounter(refreshCounter + 1);
    }
  };
}
function useGridDataProvider(fetch, dependencies) {
  const result = useDataProvider((0, import_react6.useMemo)(() => ({
    list: async (pageable) => fetch(pageable)
  }), dependencies ?? []));
  const dataProvider = result.dataProvider;
  dataProvider.refresh = result.refresh;
  return dataProvider;
}
function createComboBoxDataProvider(list, sort) {
  return new InfiniteComboBoxDataProvider(list, sort);
}
function useComboBoxDataProvider(fetch, options, dependencies) {
  const [refreshCounter, setRefreshCounter] = (0, import_react6.useState)(0);
  const dataProvider = (0, import_react6.useMemo)(() => createComboBoxDataProvider(fetch, options == null ? void 0 : options.sort), [options == null ? void 0 : options.sort, ...dependencies ?? []]);
  return (0, import_react6.useMemo)(() => {
    const dataProviderWithRefresh = (...args) => dataProvider.load(...args);
    dataProviderWithRefresh.refresh = () => {
      dataProvider.reset();
      setRefreshCounter(refreshCounter + 1);
    };
    return dataProviderWithRefresh;
  }, [dataProvider, refreshCounter]);
}

// node_modules/@vaadin/hilla-react-crud/header-sorter.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
function HeaderSorter() {
  var _a3, _b2;
  const context = (0, import_react7.useContext)(ColumnContext);
  const sorterState = context.sortState[context.propertyInfo.name];
  const direction = (sorterState == null ? void 0 : sorterState.direction) ?? null;
  const headerLabel = ((_a3 = context.customColumnOptions) == null ? void 0 : _a3.header) ?? context.propertyInfo.humanReadableName;
  return ((_b2 = context.customColumnOptions) == null ? void 0 : _b2.sortable) === false ? (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: headerLabel }) : (0, import_jsx_runtime4.jsx)(a, { path: context.propertyInfo.name, direction, onDirectionChanged: (e2) => {
    context.setSortState((prevState) => {
      const newSorterState = e2.detail.value ? { direction: e2.detail.value } : void 0;
      return { ...prevState, [context.propertyInfo.name]: newSorterState };
    });
  }, children: headerLabel });
}

// node_modules/@vaadin/hilla-react-crud/model-info.js
var javaTypeMap = {
  byte: "integer",
  "java.lang.Byte": "integer",
  short: "integer",
  "java.lang.Short": "integer",
  int: "integer",
  "java.lang.Integer": "integer",
  long: "integer",
  "java.lang.Long": "integer",
  float: "decimal",
  "java.lang.Float": "decimal",
  double: "decimal",
  "java.lang.Double": "decimal",
  "java.time.LocalDate": "date",
  "java.time.LocalTime": "time",
  "java.time.OffsetTime": "time",
  "java.time.LocalDateTime": "datetime",
  "java.time.OffsetDateTime": "datetime",
  "java.time.ZonedDateTime": "datetime",
  "java.util.Date": "datetime",
  "java.sql.Date": "datetime"
};
function determinePropertyType(model) {
  const { javaType } = model[_meta];
  const propertyType = javaType ? javaTypeMap[javaType] : void 0;
  if (propertyType) {
    return propertyType;
  }
  if (model instanceof StringModel) {
    return "string";
  } else if (model instanceof NumberModel) {
    return "decimal";
  } else if (model instanceof BooleanModel) {
    return "boolean";
  } else if (model instanceof EnumModel) {
    return "enum";
  } else if (model instanceof ObjectModel) {
    return "object";
  }
  return void 0;
}
function hasAnnotation(meta, annotationName) {
  var _a3;
  return ((_a3 = meta.annotations) == null ? void 0 : _a3.some((annotation) => annotation.name === annotationName)) ?? false;
}
function _generateHeader(path) {
  return path.substring(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match) => match.toUpperCase());
}
var getPropertyNames = (model) => {
  const propertyNames = [];
  for (let proto = model; proto !== ObjectModel; proto = Object.getPrototypeOf(proto)) {
    propertyNames.unshift(...Object.keys(Object.getOwnPropertyDescriptors(proto.prototype)).filter((p5) => p5 !== "new"));
  }
  return propertyNames;
};
var ModelInfo = class _ModelInfo {
  constructor(model, idPropertyName) {
    __publicField(this, "modelInstance");
    __publicField(this, "idProperty");
    this.modelInstance = createDetachedModel(model);
    this.idProperty = _ModelInfo.resolveIdProperty(this, idPropertyName);
  }
  static resolveIdProperty(modelInfo, idPropertyName) {
    if (idPropertyName) {
      return modelInfo.getProperty(idPropertyName);
    }
    const rootProperties = modelInfo.getRootProperties();
    let idProperty = rootProperties.find((propertyInfo) => hasAnnotation(propertyInfo.meta, "jakarta.persistence.Id"));
    if (!idProperty) {
      idProperty = rootProperties.find((propertyInfo) => propertyInfo.name === "id");
    }
    return idProperty;
  }
  static resolvePropertyModel(modelInstance, path) {
    const parts = path.split(".");
    let currentModel = modelInstance;
    for (const part of parts) {
      if (!currentModel || !(currentModel instanceof ObjectModel)) {
        return void 0;
      }
      currentModel = currentModel[part];
    }
    return currentModel;
  }
  getRootProperties(path) {
    const model = path ? _ModelInfo.resolvePropertyModel(this.modelInstance, path) : this.modelInstance;
    if (!model) {
      return [];
    }
    return getPropertyNames(model.constructor).map((name) => {
      const effectivePath = path ? `${path}.${name}` : name;
      return this.getProperty(effectivePath);
    }).filter(Boolean);
  }
  getProperty(path) {
    const propertyModel = _ModelInfo.resolvePropertyModel(this.modelInstance, path);
    if (!(propertyModel == null ? void 0 : propertyModel[_meta])) {
      return void 0;
    }
    const pathParts = path.split(".");
    const name = pathParts[pathParts.length - 1];
    const meta = propertyModel[_meta];
    const humanReadableName = _generateHeader(name);
    const type = determinePropertyType(propertyModel);
    return {
      name: path,
      humanReadableName,
      type,
      meta,
      model: propertyModel
    };
  }
  getProperties(paths) {
    return paths.map((path) => this.getProperty(path)).filter(Boolean);
  }
};
function getDefaultProperties(modelInfo) {
  const properties = modelInfo.getRootProperties();
  return properties.flatMap((prop) => {
    if (hasAnnotation(prop.meta, "jakarta.persistence.OneToOne")) {
      return modelInfo.getRootProperties(prop.name);
    }
    return prop;
  }).filter((prop) => !!prop.type && !(hasAnnotation(prop.meta, "jakarta.persistence.Id") || hasAnnotation(prop.meta, "jakarta.persistence.Version")));
}

// node_modules/@vaadin/hilla-react-crud/autogrid.js
registerStylesheet(autogrid_obj_default);
function wrapCustomColumn(column, setColumnFilter, options) {
  var _a3;
  const key = column.key ?? "no-key";
  const { header, headerRenderer } = column.props;
  const customOptions = (_a3 = options.columnOptions) == null ? void 0 : _a3[key];
  const { header: customHeader, headerRenderer: customHeaderRenderer, headerFilterRenderer } = customOptions ?? {};
  const columnWithoutHeader = (0, import_react8.cloneElement)(column, {
    header: null,
    headerRenderer: HeaderFilterWrapper
  });
  return (0, import_jsx_runtime5.jsx)(CustomColumnContext.Provider, { value: {
    setColumnFilter,
    headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,
    filterKey: key
  }, children: (0, import_jsx_runtime5.jsx)(v, { header: customHeader ?? header, headerRenderer: customHeaderRenderer ?? headerRenderer, children: columnWithoutHeader }, key) }, key);
}
function addCustomColumns(columns, options, setColumnFilter) {
  if (!options.customColumns) {
    return columns;
  }
  const customColumns = options.noHeaderFilters ? options.customColumns : options.customColumns.map((column) => wrapCustomColumn(column, setColumnFilter, options));
  if (options.visibleColumns) {
    const columnMap = [...columns, ...customColumns].reduce((map, column) => {
      const { key } = column;
      if (key) {
        map.set(key, column);
      }
      return map;
    }, /* @__PURE__ */ new Map());
    return options.visibleColumns.map((path) => columnMap.get(path)).filter(Boolean);
  }
  return [...columns, ...customColumns];
}
function useColumns(properties, setColumnFilter, options) {
  const sortableProperties = properties.filter((propertyInfo) => {
    var _a3, _b2;
    return ((_b2 = (_a3 = options.columnOptions) == null ? void 0 : _a3[propertyInfo.name]) == null ? void 0 : _b2.sortable) !== false;
  });
  const [sortState, setSortState] = (0, import_react8.useState)(sortableProperties.length > 0 ? { [sortableProperties[0].name]: { direction: "asc" } } : {});
  let columns = properties.map((propertyInfo) => {
    var _a3;
    let column;
    const customColumnOptions = (_a3 = options.columnOptions) == null ? void 0 : _a3[propertyInfo.name];
    const { headerFilterRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);
    if (!options.noHeaderFilters) {
      column = (0, import_jsx_runtime5.jsx)(v, { headerRenderer: HeaderSorter, children: (0, import_jsx_runtime5.jsx)(A, { path: propertyInfo.name, headerRenderer: HeaderFilterWrapper, ...columnProps }) });
    } else {
      column = (0, import_jsx_runtime5.jsx)(A, { path: propertyInfo.name, headerRenderer: HeaderSorter, ...columnProps });
    }
    return (0, import_jsx_runtime5.jsx)(ColumnContext.Provider, { value: {
      propertyInfo,
      setColumnFilter,
      sortState,
      setSortState,
      customColumnOptions,
      headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,
      filterKey: propertyInfo.name
    }, children: column }, propertyInfo.name);
  });
  columns = addCustomColumns(columns, options, setColumnFilter);
  if (options.hiddenColumns) {
    columns = columns.filter(({ key }) => {
      var _a3;
      return !(key && ((_a3 = options.hiddenColumns) == null ? void 0 : _a3.includes(key)));
    });
  }
  if (options.rowNumbers) {
    columns = [
      (0, import_jsx_runtime5.jsx)(A, { width: "4em", flexGrow: 0, renderer: AutoGridRowNumberRenderer }, "rownumbers"),
      ...columns
    ];
  }
  const { totalCount, filteredCount, itemCounts, footerCountRenderer } = options;
  if (totalCount ?? filteredCount) {
    const col = (0, import_jsx_runtime5.jsx)(FooterContext.Provider, { value: {
      totalCount,
      filteredCount,
      footerCountRenderer,
      itemCounts
    }, children: (0, import_jsx_runtime5.jsx)(v, { footerRenderer: AutoGridFooterItemCountRenderer, children: columns }) }, "grid-footer");
    columns = [col];
  }
  return columns;
}
function AutoGridInner({ service, model, itemIdProperty, experimentalFilter, visibleColumns, hiddenColumns, noHeaderFilters, customColumns, columnOptions, rowNumbers, totalCount, filteredCount, footerCountRenderer, ...gridProps }, ref) {
  var _a3;
  const [internalFilter, setInternalFilter] = (0, import_react8.useState)({ "@type": "and", children: [] });
  const [itemCounts, setItemCounts] = (0, import_react8.useState)();
  const gridRef = (0, import_react8.useRef)(null);
  const dataProviderRef = (0, import_react8.useRef)(void 0);
  (0, import_react8.useImperativeHandle)(ref, () => ({
    get grid() {
      return gridRef.current;
    },
    refresh() {
      var _a4, _b2;
      (_a4 = dataProviderRef.current) == null ? void 0 : _a4.reset();
      (_b2 = gridRef.current) == null ? void 0 : _b2.clearCache();
    }
  }), []);
  const setHeaderFilter = (filter, filterKey) => {
    let changed = false;
    filter.key = filterKey;
    const indexOfFilter = filterKey ? internalFilter.children.findIndex((f2) => f2.key === filterKey) : -1;
    const isEmptyFilter = isFilterEmpty(filter);
    if (indexOfFilter >= 0 && isEmptyFilter) {
      internalFilter.children.splice(indexOfFilter, 1);
      changed = true;
    } else if (!isEmptyFilter) {
      if (indexOfFilter >= 0) {
        internalFilter.children[indexOfFilter] = filter;
        changed = true;
      } else {
        internalFilter.children.push(filter);
        changed = true;
      }
    }
    if (changed) {
      setInternalFilter({ ...internalFilter });
    }
  };
  const modelInfo = (0, import_react8.useMemo)(() => new ModelInfo(model, itemIdProperty), [model]);
  const properties = visibleColumns ? modelInfo.getProperties(visibleColumns) : getDefaultProperties(modelInfo);
  const children = useColumns(properties, setHeaderFilter, {
    visibleColumns,
    hiddenColumns,
    noHeaderFilters,
    customColumns,
    columnOptions,
    rowNumbers,
    totalCount,
    filteredCount,
    footerCountRenderer,
    itemCounts
  });
  (0, import_react8.useEffect)(() => {
    if (noHeaderFilters) {
      setInternalFilter({ "@type": "and", children: [] });
    }
  }, [noHeaderFilters]);
  (0, import_react8.useEffect)(() => {
    if ((!isCountService(service) && totalCount) ?? filteredCount) {
      console.error('"totalCount" and "filteredCount" props require the provided service to implement the CountService interface.');
    }
    const grid = gridRef.current;
    const timeoutId = setTimeout(() => {
      let firstUpdate = true;
      const dataProvider = createDataProvider(service, {
        initialFilter: experimentalFilter ?? internalFilter,
        loadTotalCount: totalCount,
        afterLoad(newItemCounts) {
          setItemCounts(newItemCounts);
          if (firstUpdate) {
            firstUpdate = false;
            setTimeout(() => grid.recalculateColumnWidths(), 0);
          }
        }
      });
      dataProviderRef.current = dataProvider;
      gridRef.current.dataProvider = dataProvider.load.bind(dataProvider);
    }, 1);
    return () => clearTimeout(timeoutId);
  }, [model, service]);
  (0, import_react8.useEffect)(() => {
    const dataProvider = dataProviderRef.current;
    const grid = gridRef.current;
    if (grid && dataProvider) {
      dataProvider.setFilter(experimentalFilter ?? internalFilter);
      grid.clearCache();
    }
  }, [experimentalFilter, internalFilter]);
  return (0, import_jsx_runtime5.jsx)(D, { itemIdPath: (_a3 = modelInfo.idProperty) == null ? void 0 : _a3.name, ...gridProps, ref: gridRef, children });
}
var AutoGrid = (0, import_react8.forwardRef)(AutoGridInner);

// node_modules/@vaadin/hilla-react-crud/autogrid-feature.js
var AutoGrid2 = featureRegistration(AutoGrid, "AutoGrid");

// node_modules/@vaadin/hilla-react-crud/autoform.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@vaadin/hilla-react-form/index.js
var import_react9 = __toESM(require_react());
((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `@vaadin/hilla-react-form/${feature}` : "@vaadin/hilla-react-form",
    version: "24.7.2"
  });
})();
var isRendering = false;
function useUpdate() {
  const [_, count] = (0, import_react9.useReducer)((x) => x + 1, 0);
  return () => {
    if (isRendering) {
      return;
    }
    count();
  };
}
function convertFieldValue2(model, fieldValue) {
  return typeof fieldValue === "string" && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
function getFormPart(node) {
  return {
    addValidator: node.addValidator.bind(node),
    get defaultValue() {
      return node.defaultValue;
    },
    dirty: node.dirty,
    errors: node.errors,
    invalid: node.invalid,
    model: node.model,
    name: node.name,
    ownErrors: node.ownErrors,
    required: node.required,
    setValidators(validators) {
      node.validators = validators;
    },
    setValue(value) {
      node.value = value;
    },
    setVisited(visited) {
      node.visited = visited;
    },
    validate: node.validate.bind(node),
    validators: node.validators,
    get value() {
      return node.value;
    },
    visited: node.visited
  };
}
function useFields(node) {
  const update = useUpdate();
  return (0, import_react9.useMemo)(() => {
    const registry = /* @__PURE__ */ new WeakMap();
    return (model) => {
      isRendering = true;
      const n3 = getBinderNode(model);
      let fieldState = registry.get(model);
      if (!fieldState) {
        fieldState = {
          changeHandler() {
            fieldState.inputHandler();
            n3.validate().catch(() => {
            });
          },
          element: void 0,
          errorMessage: "",
          inputHandler() {
            if (fieldState.strategy) {
              fieldState.strategy.invalid = false;
              fieldState.strategy.checkValidity();
              n3[_validity] = fieldState.strategy.validity;
              n3.value = convertFieldValue2(model, fieldState.strategy.value);
            }
          },
          invalid: false,
          blurHandler() {
            fieldState.inputHandler();
            n3.validate().catch(() => {
            });
            n3.visited = true;
          },
          ref(element) {
            var _a3, _b2;
            if (!element) {
              (_a3 = fieldState.element) == null ? void 0 : _a3.removeEventListener("blur", fieldState.blurHandler);
              (_b2 = fieldState.strategy) == null ? void 0 : _b2.removeEventListeners();
              fieldState.element = void 0;
              fieldState.strategy = void 0;
              update();
              return;
            }
            if (!isFieldElement(element)) {
              throw new TypeError(`Element '${element.localName}' is not a form element`);
            }
            if (fieldState.element !== element) {
              fieldState.element = element;
              fieldState.element.addEventListener("blur", fieldState.blurHandler);
              fieldState.strategy = getDefaultFieldStrategy(element, model);
              fieldState.strategy.onInput = fieldState.inputHandler;
              fieldState.strategy.onChange = fieldState.changeHandler;
              update();
            }
          },
          required: false,
          strategy: void 0
        };
        registry.set(model, fieldState);
      }
      if (fieldState.strategy) {
        const valueFromField = convertFieldValue2(model, fieldState.strategy.value);
        if (valueFromField !== n3.value && !(Number.isNaN(n3.value) && Number.isNaN(valueFromField))) {
          fieldState.strategy.value = Number.isNaN(n3.value) ? "" : n3.value;
        }
        if (fieldState.required !== n3.required) {
          fieldState.required = n3.required;
          fieldState.strategy.required = n3.required;
        }
        const firstError = n3.ownErrors.at(0);
        const errorMessage = (firstError == null ? void 0 : firstError.message) ?? "";
        if (fieldState.errorMessage !== errorMessage) {
          fieldState.errorMessage = errorMessage;
          fieldState.strategy.errorMessage = errorMessage;
        }
        fieldState.invalid = n3.invalid;
        fieldState.strategy.invalid = n3.invalid;
      }
      isRendering = false;
      return {
        name: n3.name,
        ref: fieldState.ref
      };
    };
  }, [node]);
}
function useForm(Model, config) {
  const configRef = (0, import_react9.useRef)({});
  configRef.current.onSubmit = config == null ? void 0 : config.onSubmit;
  configRef.current.onChange = config == null ? void 0 : config.onChange;
  const update = useUpdate();
  const binder = (0, import_react9.useMemo)(() => new BinderRoot(Model, configRef.current), [Model]);
  const field2 = useFields(binder);
  const clear = binder.clear.bind(binder);
  (0, import_react9.useEffect)(() => {
    binder.addEventListener(CHANGED.type, update);
    clear();
    return () => binder.removeEventListener(CHANGED.type, update);
  }, [binder]);
  return {
    ...getFormPart(binder),
    clear,
    field: field2,
    read: binder.read.bind(binder),
    reset: binder.reset.bind(binder),
    setDefaultValue(defaultValue) {
      binder.defaultValue = defaultValue;
    },
    setValue(value) {
      binder.value = value;
    },
    submit: binder.submit.bind(binder),
    value: binder.value,
    submitting: binder.submitting,
    update
  };
}
function useFormPart(model) {
  isRendering = true;
  const binderNode = getBinderNode(model);
  const field2 = useFields(binderNode);
  isRendering = false;
  return {
    ...getFormPart(binderNode),
    field: field2
  };
}

// node_modules/@vaadin/hilla-react-crud/autoform.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autoform-field.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
function getPropertyModel(form, propertyInfo) {
  const pathParts = propertyInfo.name.split(".");
  return pathParts.reduce((model, property) => model ? model[property] : void 0, form.model);
}
function renderFieldElement(defaultComponentType, { element, field: field2, fieldProps }, additionalProps = {}) {
  const fieldElement = element ?? (0, import_react10.createElement)(defaultComponentType);
  return (0, import_react10.cloneElement)(fieldElement, { ...fieldProps, ...additionalProps, ...fieldElement.props, ...field2 });
}
function AutoFormTextField(props2) {
  return renderFieldElement(p2, props2);
}
function AutoFormIntegerField(props2) {
  return renderFieldElement(r2, props2);
}
function AutoFormDecimalField(props2) {
  return renderFieldElement(o, props2);
}
function AutoFormDateField(props2) {
  const i18n = useDatePickerI18n();
  return renderFieldElement(r, props2, { i18n });
}
function AutoFormTimeField(props2) {
  return renderFieldElement(k2, props2);
}
function AutoFormDateTimeField(props2) {
  const i18n = useDateTimePickerI18n();
  return renderFieldElement(k, props2, { i18n });
}
function AutoFormEnumField(props2) {
  const enumModel = props2.model;
  const items = Object.keys(enumModel[_enum]).map((value) => ({
    label: convertToTitleCase(value),
    value
  }));
  return renderFieldElement(O, props2, { items });
}
function AutoFormBooleanField(props2) {
  return renderFieldElement(h, props2);
}
function AutoFormObjectField({ model, fieldProps }) {
  const part = useFormPart(model);
  const jsonString = part.value ? JSON.stringify(part.value) : "";
  return (0, import_jsx_runtime6.jsx)(p4, { ...fieldProps, value: jsonString, readonly: true });
}
function AutoFormField(props2) {
  const { form, propertyInfo, options } = props2;
  const label = options.label ?? propertyInfo.humanReadableName;
  const model = getPropertyModel(form, propertyInfo);
  const field2 = form.field(model);
  const formPart = useFormPart(model);
  const defaultValidators = (0, import_react10.useMemo)(() => formPart.validators, []);
  const { validators } = options;
  (0, import_react10.useEffect)(() => {
    formPart.setValidators([...defaultValidators, ...validators ?? []]);
  }, [validators]);
  if (options.renderer) {
    const customFieldProps = { ...field2, disabled: props2.disabled, label };
    return options.renderer({ field: customFieldProps });
  }
  const fieldProps = {
    id: options.id,
    className: options.className,
    style: options.style,
    label,
    placeholder: options.placeholder,
    helperText: options.helperText,
    colspan: options.colspan,
    disabled: options.disabled ?? props2.disabled,
    readonly: options.readonly
  };
  const rendererProps = { model, field: field2, element: options.element, fieldProps };
  switch (props2.propertyInfo.type) {
    case "string":
      return (0, import_jsx_runtime6.jsx)(AutoFormTextField, { ...rendererProps });
    case "integer":
      return (0, import_jsx_runtime6.jsx)(AutoFormIntegerField, { ...rendererProps });
    case "decimal":
      return (0, import_jsx_runtime6.jsx)(AutoFormDecimalField, { ...rendererProps });
    case "date":
      return (0, import_jsx_runtime6.jsx)(AutoFormDateField, { ...rendererProps });
    case "time":
      return (0, import_jsx_runtime6.jsx)(AutoFormTimeField, { ...rendererProps });
    case "datetime":
      return (0, import_jsx_runtime6.jsx)(AutoFormDateTimeField, { ...rendererProps });
    case "enum":
      return (0, import_jsx_runtime6.jsx)(AutoFormEnumField, { ...rendererProps });
    case "boolean":
      return (0, import_jsx_runtime6.jsx)(AutoFormBooleanField, { ...rendererProps });
    case "object":
      return (0, import_jsx_runtime6.jsx)(AutoFormObjectField, { ...rendererProps });
    default:
      return null;
  }
}

// node_modules/@vaadin/hilla-react-crud/autoform.obj.js
var css2 = new CSSStyleSheet();
css2.replaceSync(`.auto-form{display:flex;flex-direction:column;gap:var(--lumo-space-m)}.auto-form-toolbar{align-items:center;display:flex;flex-direction:row-reverse;gap:var(--lumo-space-xs) var(--lumo-space-s);justify-content:flex-start}.auto-form-delete-button{margin-right:auto}`);
var autoform_obj_default = css2;

// node_modules/@vaadin/hilla-react-crud/autoform.js
registerStylesheet(autoform_obj_default);
var emptyItem = Symbol();
function AutoForm({ service, model, itemIdProperty, item = emptyItem, onSubmitError, onSubmitSuccess, disabled, layoutRenderer: LayoutRenderer, visibleFields, hiddenFields, formLayoutProps, fieldOptions, style, id, className, deleteButtonVisible, onDeleteSuccess, onDeleteError }) {
  const form = useForm(model, {
    onSubmit: async (formItem) => service.save(formItem)
  });
  const formErrorRef = (0, import_react11.useRef)(null);
  const [formError, setFormError] = (0, import_react11.useState)("");
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react11.useState)(false);
  const modelInfo = (0, import_react11.useMemo)(() => new ModelInfo(model, itemIdProperty), [model]);
  const isEditMode = item !== void 0 && item !== null && item !== emptyItem;
  const showDeleteButton = deleteButtonVisible && isEditMode && modelInfo.idProperty;
  const isSubmitDisabled = !!disabled || isEditMode && !form.dirty;
  (0, import_react11.useEffect)(() => {
    if (item !== emptyItem) {
      form.read(item);
    } else {
      form.clear();
    }
  }, [item]);
  (0, import_react11.useEffect)(() => {
    var _a3;
    (_a3 = formErrorRef.current) == null ? void 0 : _a3.scrollIntoView({ behavior: "smooth", block: "end" });
  }, [formError]);
  function handleSubmitError(error) {
    if (error instanceof ValidationError) {
      const nonPropertyErrorMessages = error.errors.filter((validationError) => !validationError.property || typeof validationError.property === "string").map((validationError) => {
        const property = validationError.property && typeof validationError.property === "string" ? `${validationError.property}: ` : "";
        return `${property}${validationError.validatorMessage ?? validationError.message}`;
      });
      if (nonPropertyErrorMessages.length > 0) {
        setFormError((0, import_jsx_runtime7.jsxs)("div", { ref: formErrorRef, children: ["Validation errors:", (0, import_jsx_runtime7.jsx)("ul", { children: nonPropertyErrorMessages.map((message, index) => (0, import_jsx_runtime7.jsx)("li", { children: message }, index)) })] }));
      }
    } else if (error instanceof EndpointError) {
      if (onSubmitError) {
        onSubmitError({ error, setMessage: setFormError });
      } else {
        setFormError(error.message);
      }
    } else {
      throw error;
    }
  }
  async function handleSubmit() {
    try {
      setFormError("");
      const newItem = await form.submit();
      if (newItem === void 0) {
        throw new EndpointError("No update performed");
      } else if (onSubmitSuccess) {
        onSubmitSuccess({ item: newItem });
      }
      if (!item || item === emptyItem) {
        form.clear();
      }
    } catch (error) {
      handleSubmitError(error);
    }
  }
  function deleteItem() {
    setShowDeleteDialog(true);
  }
  async function confirmDelete() {
    const deletedItem = item;
    try {
      const idProperty = modelInfo.idProperty;
      const id2 = item[idProperty.name];
      await service.delete(id2);
      if (onDeleteSuccess) {
        onDeleteSuccess({ item: deletedItem });
      }
    } catch (error) {
      if (error instanceof EndpointError) {
        if (onDeleteError) {
          onDeleteError({ error, setMessage: setFormError });
        } else {
          setFormError(error.message);
        }
      } else {
        throw error;
      }
    } finally {
      setShowDeleteDialog(false);
    }
  }
  function cancelDelete() {
    setShowDeleteDialog(false);
  }
  const handleKeyDown = (event) => {
    if (event.target instanceof HTMLTextAreaElement) {
      return;
    }
    if (event.key === "Enter" && !isSubmitDisabled) {
      void handleSubmit();
    }
  };
  function createAutoFormField(propertyInfo) {
    const fieldOptionsForProperty = (fieldOptions == null ? void 0 : fieldOptions[propertyInfo.name]) ?? {};
    return (0, import_jsx_runtime7.jsx)(AutoFormField, { propertyInfo, form, disabled, options: fieldOptionsForProperty }, propertyInfo.name);
  }
  let visibleProperties = visibleFields ? modelInfo.getProperties(visibleFields) : getDefaultProperties(modelInfo);
  if (hiddenFields) {
    visibleProperties = visibleProperties.filter(({ name }) => !hiddenFields.includes(name));
  }
  const fields = visibleProperties.map(createAutoFormField);
  const layout = LayoutRenderer ? (0, import_jsx_runtime7.jsx)(LayoutRenderer, { form, children: fields }) : (0, import_jsx_runtime7.jsx)(p3, { ...formLayoutProps, children: fields });
  return (0, import_jsx_runtime7.jsxs)("div", { className: `auto-form ${className ?? ""}`, id, style, "data-testid": "auto-form", children: [(0, import_jsx_runtime7.jsxs)(m3, { className: "auto-form-fields", onKeyDown: handleKeyDown, children: [layout, formError ? (0, import_jsx_runtime7.jsx)("div", { style: { color: "var(--lumo-error-color)" }, children: formError }) : (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, {})] }), (0, import_jsx_runtime7.jsxs)("div", { className: "auto-form-toolbar", children: [(0, import_jsx_runtime7.jsx)(m2, { theme: "primary", disabled: isSubmitDisabled, onClick: handleSubmit, children: "Submit" }), form.dirty ? (0, import_jsx_runtime7.jsx)(m2, { theme: "tertiary", onClick: () => form.reset(), children: "Discard" }) : null, showDeleteButton && (0, import_jsx_runtime7.jsx)(m2, { className: "auto-form-delete-button", theme: "tertiary error", onClick: deleteItem, children: "Delete..." })] }), showDeleteDialog && (0, import_jsx_runtime7.jsx)(f, { opened: true, header: "Delete item", confirmTheme: "error", cancelButtonVisible: true, onConfirm: confirmDelete, onCancel: cancelDelete, children: "Are you sure you want to delete the selected item?" })] });
}

// node_modules/@vaadin/hilla-react-crud/autoform-feature.js
var AutoForm2 = featureRegistration(AutoForm, "AutoForm");

// node_modules/@vaadin/hilla-react-crud/autocrud.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-crud/autocrud-dialog.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
import "@vaadin/vaadin-lumo-styles/vaadin-iconset.js";
function AutoCrudDialog(props2) {
  const { header, children, opened, onClose } = props2;
  return (0, import_jsx_runtime8.jsx)(T, { overlayClass: "auto-crud-dialog", opened, headerRenderer: () => (0, import_jsx_runtime8.jsxs)("div", { className: "auto-crud-dialog-header", children: [header, (0, import_jsx_runtime8.jsx)(m2, { theme: "tertiary", onClick: onClose, "aria-label": "Close", children: (0, import_jsx_runtime8.jsx)(m, { icon: "lumo:cross", style: { height: "var(--lumo-icon-size-l)", width: "var(--lumo-icon-size-l)" } }) })] }), children });
}

// node_modules/@vaadin/hilla-react-crud/autocrud.obj.js
var css3 = new CSSStyleSheet();
css3.replaceSync(`.auto-crud{border:1px solid var(--lumo-contrast-20pct);display:flex;height:462px;overflow:hidden}.auto-crud>vaadin-split-layout{align-items:stretch;flex:1 1 100%}.auto-crud>vaadin-split-layout::part(splitter){border-left:1px solid var(--lumo-contrast-20pct);border-top:1px solid var(--lumo-contrast-20pct)}.auto-crud-main{display:flex;flex:1 1 100%;flex-direction:column;min-width:200px}.auto-crud-main>vaadin-grid{border:none;height:auto}.auto-crud-toolbar{align-items:baseline;background-color:var(--lumo-contrast-5pct);border-top:1px solid var(--lumo-contrast-10pct);display:flex;flex-shrink:0;justify-content:flex-end;padding:var(--lumo-space-s) var(--lumo-space-m)}.auto-crud-form{align-items:stretch;display:flex;flex-direction:column;min-width:300px;width:40%}.auto-crud .auto-crud-form:before{box-shadow:var(--lumo-box-shadow-s);content:"";height:100%;pointer-events:none;position:absolute;width:100%;z-index:1}.auto-crud-form-header{padding:var(--lumo-space-m) var(--lumo-space-m) var(--lumo-space-s) var(--lumo-space-m)}.auto-crud .auto-form,.auto-crud-dialog .auto-form{align-items:stretch;display:flex;flex:1 1 0;flex-direction:column}.auto-crud .auto-form-fields,.auto-crud-dialog .auto-form-fields{flex:1 1 0;min-height:0;overflow-y:auto;padding:0 var(--lumo-space-m)}.auto-crud .auto-form-toolbar,.auto-crud-dialog .auto-form-toolbar{background-color:var(--lumo-contrast-5pct);border-top:1px solid var(--lumo-contrast-10pct);flex:0 0 auto;padding:var(--lumo-space-s) var(--lumo-space-m)}.auto-crud-dialog{bottom:0;left:0;right:0;top:0}.auto-crud-dialog::part(overlay){border-radius:0;height:100%;width:100%}.auto-crud-dialog::part(content){padding:0}.auto-crud-dialog .auto-crud-dialog-header{align-items:center;display:flex;justify-content:space-between;width:100%}.auto-crud-dialog .auto-form{height:100%;width:100%}`);
var autocrud_obj_default = css3;

// node_modules/@vaadin/hilla-react-crud/media-query.js
var import_react12 = __toESM(require_react(), 1);
function useMediaQuery(query) {
  const [matches2, setMatches] = (0, import_react12.useState)(() => window.matchMedia(query).matches);
  (0, import_react12.useEffect)(() => {
    const listener = (e2) => setMatches(e2.matches);
    const mediaQuery = window.matchMedia(query);
    setMatches(mediaQuery.matches);
    mediaQuery.addEventListener("change", listener);
    return () => mediaQuery.removeEventListener("change", listener);
  }, [query]);
  return matches2;
}

// node_modules/@vaadin/hilla-react-crud/autocrud.js
registerStylesheet(autocrud_obj_default);
function defaultFormHeaderRenderer(editedItem, disabled) {
  const style = { color: disabled ? "var(--lumo-disabled-text-color)" : "var(--lumo-text-color)" };
  return editedItem ? (0, import_jsx_runtime9.jsx)("h3", { style, children: "Edit item" }) : (0, import_jsx_runtime9.jsx)("h3", { style, children: "New item" });
}
function AutoCrud({ service, model, itemIdProperty, noNewButton, formProps, gridProps, style, id, className }) {
  const [item, setItem] = (0, import_react13.useState)(void 0);
  const fullScreen = useMediaQuery("(max-width: 600px), (max-height: 600px)");
  const autoGridRef = (0, import_react13.useRef)(null);
  const { headerRenderer: customFormHeaderRenderer, ...autoFormProps } = formProps ?? {};
  const formHeaderRenderer = customFormHeaderRenderer ?? defaultFormHeaderRenderer;
  const autoCrudId = (0, import_react13.useId)();
  function refreshGrid() {
    var _a3;
    (_a3 = autoGridRef.current) == null ? void 0 : _a3.refresh();
  }
  function handleCancel() {
    setItem(void 0);
  }
  const formHeader = item && item !== emptyItem ? formHeaderRenderer(item, !item) : formHeaderRenderer(null, !item);
  const mainSection = (0, import_jsx_runtime9.jsxs)("div", { className: "auto-crud-main", children: [(0, import_jsx_runtime9.jsx)(AutoGrid, { ...gridProps, service, model, itemIdProperty, selectedItems: item && item !== emptyItem ? [item] : [], onActiveItemChanged: (e2) => {
    const activeItem = e2.detail.value;
    setItem(activeItem ?? void 0);
  }, ref: autoGridRef, "aria-controls": autoFormProps.id ?? `auto-form-${id ?? autoCrudId}` }), !noNewButton && (0, import_jsx_runtime9.jsx)("div", { className: "auto-crud-toolbar", children: (0, import_jsx_runtime9.jsx)(m2, { theme: "primary", onClick: () => setItem(emptyItem), children: "+ New" }) })] });
  const autoForm = (0, import_jsx_runtime9.jsx)(AutoForm, { id: autoFormProps.id ?? `auto-form-${id ?? autoCrudId}`, deleteButtonVisible: true, ...autoFormProps, disabled: !item, service, model, itemIdProperty, item, onSubmitSuccess: ({ item: submittedItem }) => {
    if (fullScreen) {
      setItem(void 0);
    } else {
      setItem(submittedItem);
    }
    refreshGrid();
  }, onDeleteSuccess: () => {
    setItem(void 0);
    refreshGrid();
  } });
  return (0, import_jsx_runtime9.jsx)("div", { className: `auto-crud ${className ?? ""}`, id, style, children: noNewButton && (!item || item === emptyItem) ? mainSection : fullScreen ? (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [mainSection, (0, import_jsx_runtime9.jsx)(AutoCrudDialog, { opened: !!item, header: formHeader, onClose: handleCancel, children: autoForm })] }) : (0, import_jsx_runtime9.jsxs)(n2, { theme: "small", children: [mainSection, (0, import_jsx_runtime9.jsxs)("div", { className: "auto-crud-form", children: [(0, import_jsx_runtime9.jsx)("div", { className: "auto-crud-form-header", children: formHeader }), autoForm] })] }) });
}

// node_modules/@vaadin/hilla-react-crud/autocrud-feature.js
var AutoCrud2 = featureRegistration(AutoCrud, "AutoCrud");

// node_modules/@vaadin/hilla-react-crud/index.js
((feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) => {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `@vaadin/hilla-react-crud/${feature}` : "@vaadin/hilla-react-crud",
    version: "24.7.2"
  });
})();
export {
  AutoCrud2 as AutoCrud,
  AutoForm2 as AutoForm,
  AutoGrid2 as AutoGrid,
  emptyItem,
  useComboBoxDataProvider,
  useDataProvider,
  useGridDataProvider
};
//# sourceMappingURL=@vaadin_hilla-react-crud.js.map
